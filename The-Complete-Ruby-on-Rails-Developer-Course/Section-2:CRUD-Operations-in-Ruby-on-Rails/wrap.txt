*** 1-Tables, migrations and naming conventions ***

- we're going to build these basically the entire
articles resource from scratch so we understand all the code that goes into it.

we will start with article table and article model
Rails naming convention:
Article resource
Model name: article
Article Model file name: article.rb
Article model class name Article

Table: articles
id: called the primary key
title: string have limit with 255 char
description: text has more that 255 char
-------------------code----------------------
id | title | description
1  |  first_article  | description_of_first_description
2  |  second_article | description_of_second_description
3  |  third_article  | description_of_third_description
4  |  fourth_article | description_of_third_description
-------------------code----------------------

- we create our table using so do that we need to create migration file
the name of the migration file should  be something we understand later on and named using Snakecase.
-------------------code----------------------
rails g migration create_articles
-------------------code----------------------

in the terminal we see that it
-------------------code----------------------
invoke  active_record
create    db/migrate/20241214064512_create_articles.rb
-------------------code----------------------

- the file will be created inside the db/migrate folder 
the first part of the file name is  20241214064512 is the timestamp
And Rails will use this to track migration files as they are created. This is the only reason we actually used a generator to create this file instead of creating it by hand.
The ordering of migration files as we create more of them will be very important.

because of the way we named our migration file Create articles, Rails was smart enough to
know that we wanted to create an articles table.
within this define change method that we have, it has the code necessary to create the articles
table pre filled in, but it has no details within this code block.
So what we'll do is we're going to go ahead and add our title attribute within this code.

it crete to us this migration
-------------------code----------------------
class CreateArticles < ActiveRecord::Migration[8.0]
  def change
    create_table :articles do |t|
      t.timestamps
    end
  end
end
-------------------code----------------------

- now we add the data that we need the title
-------------------code----------------------
class CreateArticles < ActiveRecord::Migration[8.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.timestamps
    end
  end
end
-------------------code----------------------


- now we migrate our file
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- in the console we got 
-------------------code----------------------
== 20241214070114 CreateArticles: migrating ===================================
-- create_table(:articles)
   -> 0.0009s
== 20241214070114 CreateArticles: migrated (0.0009s) ==========================
-------------------code----------------------

- now we can check the table detail in the schema file db/schema
what is schema:
auto-generated file that represents the current state of your database schema. 
It is created based on the migrations that have been run in your application. 
-------------------code---------------------- 
ActiveRecord::Schema[8.0].define(version: 2024_12_14_070114) do
  create_table "articles", force: :cascade do |t|
    t.string "title"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
-------------------code----------------------



PS:
Rails will only run migration files that have not been run already.


so if we run the migrate command again
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- nothing happens cause it runs any un run migration files or any new migration files
since the last time we issued this command.

- now at this point 
even if I wanted to change something in this migration file
let`s say we want to add the description
-------------------code---------------------- 
class CreateArticles < ActiveRecord::Migration[8.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :description
      t.timestamps
    end
  end
end
-------------------code----------------------

- now if i run  Rails DB migrate again, nothing happened
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- and if we open the schema file we can see the article table
not updated. 
so why?

- So in this scenario, if we wanted to change an existed migration file what we are going to 
do the rollback
-------------------code----------------------
rails db:rollback
-------------------code----------------------

the migration file has reverting
-------------------code----------------------
== 20241214070114 CreateArticles: reverting ===================================
-- drop_table(:articles)
   -> 0.0012s
== 20241214070114 CreateArticles: reverted (0.0020s) ==========================
-------------------code----------------------

and if we open the schema file we see it became empty
-------------------code----------------------
ActiveRecord::Schema[8.0].define(version: 0) do
end
-------------------code----------------------

and then change the file 
finally rerun 
-------------------code----------------------
rails db:migrate
-------------------code----------------------

we can see the schema file is updated
-------------------code----------------------
ActiveRecord::Schema[8.0].define(version: 2024_12_14_070114) do
  create_table "articles", force: :cascade do |t|
    t.string "title"
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end

-------------------code----------------------

PS: is not the preferred way to do that, basically in rails we don`t change an existed 
migration file after created it

And there are a few reasons.
And there are several reasons for this.
One key reason is that you will likely collaborate with team members, sharing code repositories. Migration files will run on their machines as well.
If a team member pulls the latest changes, including updates to a previous migration, those changes won't reflect in their database since that migration has already been executed on their system.
This can lead to codebases being out of sync, which is why modifying existing migration files is discouraged.

so instead always create 
Instead, always create a new migration file for any database changes. 
This way, when a team member downloads the latest code, the new changes will be reflected in the new migration file. 
When they run `rails db:migrate`, it will apply the updates instead of ignoring an earlier modified migration file.

- let`s say we want to publisher felid

- we create new migration file and give it name that relevant "add_publisher_to_articles"
-------------------code----------------------
rails g migration add_publisher_to_articles
-------------------code----------------------

- now rails didn`t know which changes to do it create custom migrate file with change method 
early cause we prefix the migration file with create the rails knows that we want to create table 
so the migration file start with create table but now it dose`t  know so we have only change method
-------------------code----------------------
class AddPublisherToArticles < ActiveRecord::Migration[8.0]
  def change
  end
end
-------------------code----------------------

- now we add the "add_column" method to add column to an existed table and the first argument 
to provide will be the table name and the second attribute will be the column name and the third attribute 
will be the column name and the forth attribute will be the data type
-------------------code----------------------
class AddPublisherToArticles < ActiveRecord::Migration[8.0]
  def change
    add_column :articles, :publisher, :string 
  end
end
-------------------code----------------------

- now we new migration file that has not run before to check that we use the 
-------------------code----------------------
rails db:migrate:status
-------------------code----------------------

- We see "up" and "down" next to each migration file. 
- The command `rails db:migrate` only applies migrations with the status "down".
- To change the status of a migration, we use the rollback command, which sets it to "down".
- After rolling back, we can run `rails db:migrate` again to apply the changes and set the migration status to "up".
- Only migrations with the status "up" are reflected in the schema.
- When we create a new migration file, its initial status is "down" until we apply it.
-------------------code----------------------
database: storage/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20241214070114  Create articles
  down    20241214073037  Add publisher to articles
-------------------code----------------------

- now when the migrate command 
-------------------code----------------------
rails db:migrate
-------------------code----------------------

and the the stats of the migration file we can see it became up 
-------------------code----------------------
database: storage/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20241214070114  Create articles
   up     20241214073037  Add publisher to articles
-------------------code----------------------

and we can see it reflected on the schema
-------------------code----------------------
ActiveRecord::Schema[8.0].define(version: 2024_12_14_073037) do
  create_table "articles", force: :cascade do |t|
    t.string "title"
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.string "publisher"
  end
end
-------------------code----------------------



*** 2-Models and rails console *** 
In the last lesson we created this articles table with the title and description Fields.
Now we need for a way to communicate with this table from our Rails application.

and to do that we use the Models:
Rails naming convention:
Article resource
Model name: article
Article Model file name: article.rb
Article model class name Article

- we create the model file app/models/article.rb or by using the command
-------------------code----------------------
rails g model article
-------------------code----------------------

- but because we created the article migration before we can`t use the command and we need to create it the 
model manually 

- every Model we create 
Every model we create will inherit from this file, which is the application record model file.
and the naming is in camelcase where each word start with capitalized alphabet.
-------------------code----------------------
class Article < ApplicationRecord

end
-------------------code----------------------

that`s means of we but any code in the application_record.rb it will apply for all our model files

- we use the Rails console to communicate with database

- now we test our connection to our data base
by using the model with all method , and it generate a sql query
And the response we got was this empty collection or array like structure from the table, which means
that the connection is working. But there are no articles in my articles table. 
-------------------code----------------------
Article.all
  Article Load (7.0ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=> []
-------------------code----------------------

- now we create record by using the create method
ps the id is auto generated by the server we don`t add it manually
-------------------code----------------------
Article.create(title: "article1", description: "this is the first article")
-------------------code----------------------
- and we got 
-------------------code----------------------
TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (1.9ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('article1', 'this is the first article', '2024-12-17 10:56:55.496899', '2024-12-17 10:56:55.496899', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.5ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=>
#<Article:0x0000000106e37860
 id: 1,
 title: "article1",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-17 10:56:55.496899000 +0000",
 publisher: nil>
>
-------------------code----------------------
******************************************************************************************************
What is Transaction?

1. Transaction: A transaction is a sequence of one or more SQL operations that are executed as a single unit. Transactions ensure that either all operations are completed successfully or none are applied,
maintaining the integrity of the database.
2. BEGIN: When a transaction starts, it is initiated with a BEGIN statement. 
This marks the beginning of the transaction.

3.COMMIT: After executing the necessary operations (like inserting, updating, or deleting records),
the COMMIT statement is issued. This finalizes the transaction, making all changes made during the transaction permanent in the database.

4.Rollback: If something goes wrong during the transaction (e.g., an error occurs), a ROLLBACK can be issued instead of a commit. This undoes all changes made during the transaction, reverting the database to its previous state.
******************************************************************************************************

- now we got id that generate by the server which is 1
So the first ID was one, there's the title, there's the description, and rails also filled in the
timestamps automatically for us.


- now if we wrote the Article.all we can see our created record 
-------------------code----------------------
> Article.all
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<Article:0x000000010504adc0
  id: 1,
  title: "article1",
  description: "this is the first article",
  created_at: "2024-12-17 10:56:55.496899000 +0000",
  updated_at: "2024-12-17 10:56:55.496899000 +0000",
  publisher: nil>]
-------------------code----------------------

- now a better way to create an article
instead of directly calling the class, what I'll do is create a variable article with lowercase
A so it's a variable instead of the class, and then I'll assign it to a new article object.
-------------------code----------------------
article = Article.new
-------------------code----------------------

The value 0x0000000105046f40 is a memory address in hexadecimal format. 
In Ruby, when you create an object (like an instance of the Article class), 
the Ruby interpreter allocates memory for that object and assigns it a unique address in memory.
-------------------code----------------------
=> #<Article:0x0000000105046f40 id: nil, title: nil, description: nil, created_at: nil, updated_at: nil, publisher: nil>
-------------------code----------------------



Now because we have the model rails gives me getters and setters to fill in the attributes that we want
we can do like 
-------------------code----------------------
article.title = "second article"
-------------------code----------------------
and the same for description
-------------------code----------------------
article.description = "this is the second article"
=> "this is the second article"
-------------------code----------------------

- now if we type "article"
we see the id is nill that means the object is not saved to the data base
so it`s still object in the memory and not yet a record in the data base
-------------------code----------------------
> article
=>
#<Article:0x0000000105046f40
 id: nil,
 title: "second article",
 description: "this is the second article",
 created_at: nil,
 updated_at: nil,
 publisher: nil>
>
-------------------code----------------------

- now we save the object to the db using the "save" command
-------------------code----------------------
> article.save
TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (8.4ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('second article', 'this is the second article', '2024-12-17 12:31:51.612805', '2024-12-17 12:31:51.612805', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.4ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------

save vs save!
******************************************************************************************************
save:
Behavior: Attempts to save the object to the database.
Return Value: Returns true if the save is successful and false if it fails (e.g., due to validation errors).
Error Handling: Does not raise an exception on failure. Instead, you can check the object's errors collection to see what went wrong.

save!
Behavior: Also attempts to save the object to the database.
Return Value: Returns true if the save is successful.
Error Handling: Raises an ActiveRecord::RecordInvalid exception if the save fails due to validation errors. This is useful for ensuring that you handle errors explicitly.
******************************************************************************************************

- now if we type Article.all we see two records
-------------------code----------------------
> Article.all
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<Article:0x0000000106f7cd10
  id: 1,
  title: "article1",
  description: "this is the first article",
  created_at: "2024-12-17 10:56:55.496899000 +0000",
  updated_at: "2024-12-17 10:56:55.496899000 +0000",
  publisher: nil>,
 #<Article:0x0000000106f7cbd0
  id: 2,
  title: "second article",
  description: "this is the second article",
  created_at: "2024-12-17 12:31:51.612805000 +0000",
  updated_at: "2024-12-17 12:31:51.612805000 +0000",
  publisher: nil>]
-------------------code----------------------

- now we check our article object we see the id of it became 
2 that`s means it saved to the database
-------------------code----------------------
> article
=>
#<Article:0x0000000105046f40
 id: 2,
 title: "second article",
 description: "this is the second article",
 created_at: "2024-12-17 12:31:51.612805000 +0000",
 updated_at: "2024-12-17 12:31:51.612805000 +0000",
 publisher: nil>
-------------------code----------------------


- the third way is 
-------------------code----------------------
article = Article.new(title: "article3", description: "this is the third article")
=> #<Article:0x00000001060c21d0 id: nil, title: "article3", description: "this is the third article", created_at: nil, updated_at: nil, publisher: ...
-------------------code----------------------

- then use the save! method
-------------------code----------------------
> article.save!
  TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (1.6ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('article3', 'this is the third article', '2024-12-17 12:38:41.285133', '2024-12-17 12:38:41.285133', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.4ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------

- finally we use our Article.all to check our all records
-------------------code----------------------
> Article.all
  Article Load (0.2ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<Article:0x0000000106fdd0c0
  id: 1,
  title: "article1",
  description: "this is the first article",
  created_at: "2024-12-17 10:56:55.496899000 +0000",
  updated_at: "2024-12-17 10:56:55.496899000 +0000",
  publisher: nil>,
 #<Article:0x0000000106fdcf80
  id: 2,
  title: "second article",
  description: "this is the second article",
  created_at: "2024-12-17 12:31:51.612805000 +0000",
  updated_at: "2024-12-17 12:31:51.612805000 +0000",
  publisher: nil>,
 #<Article:0x0000000106fdce40
  id: 3,
  title: "article3",
  description: "this is the third article",
  created_at: "2024-12-17 12:38:41.285133000 +0000",
  updated_at: "2024-12-17 12:38:41.285133000 +0000",
  publisher: nil>]
-------------------code----------------------

- we can close the console by using exit or "ctrl + c" or "ctrl + d" 

*** 3-CRUD operations from rails console ***
to get a data we have multi ways:
- using the find with number of the id
-------------------code----------------------
Article.find(1)
-------------------code----------------------

the result:
-------------------code----------------------
  Article Load (0.4ms)  SELECT "articles".* FROM "articles" WHERE "articles"."id" = 3 LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x00000001068bf018
 id: 3,
 title: "article3",
 description: "this is the third article",
 created_at: "2024-12-17 12:38:41.285133000 +0000",
 updated_at: "2024-12-17 12:38:41.285133000 +0000",
 publisher: nil>
-------------------code----------------------


- but what if we want to get the first Article
and the first article does`nt start with id 1
-------------------code----------------------
Article.first
-------------------code----------------------

it return a different sql query and show the first article regardless of the id number
-------------------code----------------------
Article Load (0.2ms)  SELECT "articles".* FROM "articles" ORDER BY "articles"."id" ASC LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x00000001071599d0
 id: 1,
 title: "article1",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-17 10:56:55.496899000 +0000",
 publisher: nil>
 -------------------code----------------------

PS: if we want to change that record we should save it to a variable
-------------------code----------------------
a = Article.first
-------------------code----------------------

The article model gives us getters and setters for the attributes of our articles so I can use the getters
available and directly call on the attribute.


or if we want to check only data 
-------------------code----------------------
> a.title
=> "article1"
-------------------code----------------------

- or we can use the setter to edit the value and updated
-------------------code----------------------
> a.title = "new title"
=> "new title"
-------------------code----------------------

- now we see the a 
-------------------code----------------------
> a
=>
#<Article:0x000000010715c590
 id: 1,
 title: "new title",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-18 10:51:04.932181000 +0000",
 publisher: nil>
-------------------code----------------------

- but the data is not save in database yet only exist in the memory
if we type Article.first we can see the data in database still not edited
-------------------code----------------------
> Article.first
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" ORDER BY "articles"."id" ASC LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x0000000107153e90
 id: 1,
 title: "article1",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-18 10:51:04.932181000 +0000",
 publisher: nil>
-------------------code----------------------

- so we need to save it to be updated in the database
-------------------code----------------------
> a.save!
  TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Update (1.5ms)  UPDATE "articles" SET "title" = 'new title', "updated_at" = '2024-12-18 10:53:32.363168' WHERE "articles"."id" = 1 /*application='RailsApp'*/
  TRANSACTION (1.1ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------

- now if we check the database we can see it changed
-------------------code----------------------
> Article.first
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" ORDER BY "articles"."id" ASC LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x00000001071526d0
 id: 1,
 title: "new title",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-18 10:53:32.363168000 +0000",
 publisher: nil>
-------------------code----------------------

- next we will see the delete operation

- now we will grab the last one
-------------------code----------------------
a_last = Article.last
-------------------code----------------------

to delete it we have tow ways:
using delete or using destroy
Ps: 
- only have delete method
while destroy have destroy and destroy!

- the destroy or delete method no need to use save! 
it does the operation automatically

what is the difference between delete and destroy?
******************************************************************************************************
delete
Method: delete
Behavior: Deletes the record directly from the database without instantiating the ActiveRecord object.
Callbacks: Does not trigger any ActiveRecord callbacks (like before_destroy or after_destroy).
Associations: Does not handle dependent associations. If there are any dependent records, they will not be deleted.
Return Value: Returns the deleted record (as an instance of the model) or nil if the record was not found.
-------------------code----------------------
article = Article.find(1)
article.delete
-------------------code----------------------

destroy
Method: destroy
Behavior: Instantiates the ActiveRecord object and then deletes it from the database.
Callbacks: Triggers all ActiveRecord callbacks, including before_destroy and after_destroy. 
This is useful for cleaning up related data or performing other actions before or after the record is deleted.
Associations: Handles dependent associations according to the dependent option specified in the model (e.g., dependent: :destroy).
-------------------code----------------------
Return Value: Returns the deleted record (as an instance of the model).
article = Article.find(1)
article.destroy
-------------------code----------------------

Summary
Use delete when you want to quickly remove a record without any callbacks or associated records being affected.
Use destroy when you need to ensure that callbacks are executed and any dependent records are also handled appropriately.
******************************************************************************************************


- now if we have problem in our model 
our model file is empty which means there is no rules for creating data or updating or deleting it at all
so we can crete article with empty title and empty description
and it`s bad practice 

ex:
- we create empty article
-------------------code----------------------
a = Article.new
-------------------code----------------------

- then we can save it 
-------------------code----------------------
a.save!
-------------------code----------------------

- and if we see the data it`s empty
-------------------code----------------------
> Article.last
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" ORDER BY "articles"."id" DESC LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x000000010a43a7a0
 id: 4,
 title: nil,
 description: nil,
 created_at: "2024-12-18 11:05:26.602293000 +0000",
 updated_at: "2024-12-18 11:05:26.602293000 +0000",
 publisher: nil>
-------------------code----------------------


- it`s not valid record so we destroy it 
-------------------code----------------------
Article.last.destroy!
-------------------code----------------------

*** 4-Validations ***

we will work to add validation into article model to avoid 
creating invalid data
 
Validation:
in the context of a Rails application refers to the process of ensuring 
that the data being saved to the database meets certain 
criteria or rules before it is actually saved. 
This is crucial for maintaining data integrity and ensuring that the application behaves as expected.

- now we want to add validation that articles without
a title are not saved to the database.

- so inside the app/model/article.rb file 
we use the "validates" keyword with the "presence" option and set it to true 
-------------------code----------------------
class Article < ApplicationRecord
  validates :title, presence: true
end
-------------------code----------------------

- now let`s test our validation
before that if we already opened the console we need to reload 
by pressing 
-------------------code----------------------
reload!
-------------------code----------------------

- or close the console and reopened it

- now we create new record
-------------------code----------------------
article = Article.new
=> #<Article:0x0000000109a79900 id: nil, title: nil, description: nil, created_at: nil, updated_at: nil, publisher: nil>
-------------------code----------------------

- now if we tried to save it we got false 
-------------------code----------------------
> article.save
=> false
-------------------code----------------------

- to see the error why we use save!
-------------------code----------------------
> article.save!
(rails-app):7:in `<main>': Validation failed: Title can't be blank (ActiveRecord::RecordInvalid)
-------------------code----------------------

- or we can see the error using the "errors" method
-------------------code----------------------
> article.errors
=> #<ActiveModel::Errors [#<ActiveModel::Error attribute=title, type=blank, options={}>]>
-------------------code----------------------

- and if we want to read the message clearly we use errors.full_message
-------------------code----------------------
> article.errors.full_messages
=> ["Title can't be blank"]
-------------------code----------------------

- now we do the same thing for the description
and we hit reload!
-------------------code----------------------
class Article < ApplicationRecord
  validates :title, presence: true
  validates :description, presence: true
end
-------------------code----------------------

and then create new article to test 
-------------------code----------------------
> article = Article.new
=> #<Article:0x0000000109ad7f28 id: nil, title: nil, description: nil, created_at: nil, updated_at: nil, publisher: nil>
> article.save!
(rails-app):16:in `<main>': Validation failed: Title can't be blank, Description can't be blank (ActiveRecord::RecordInvalid)
> article.errors.full_messages
=> ["Title can't be blank", "Description can't be blank"]
-------------------code----------------------

- now if we add the title only and test it we see
we can`t save it too cause the description still empty 
-------------------code----------------------
> article.title = "test"
=> "test"
> article.save!
(rails-app):19:in `<main>': Validation failed: Description can't be blank (ActiveRecord::RecordInvalid)
> article.errors.full_messages
=> ["Description can't be blank"]
-------------------code----------------------

- now if we add the description we can save it 
-------------------code----------------------
> article.description = "test description"
=> "test description"
> article.save!
  TRANSACTION (0.0ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (4.2ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('test', 'test description', '2024-12-21 07:36:28.069685', '2024-12-21 07:36:28.069685', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.3ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------


- now we test another pattern if we create article with only one alphabet
-------------------code----------------------
> article = Article.new(title: "a", description: "b")
=> #<Article:0x0000000109af8c00 id: nil, title: "a", description: "b", created_at: nil, updated_at: nil, publisher: nil>
> article.save!
  TRANSACTION (0.2ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (2.2ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('a', 'b', '2024-12-21 07:38:31.073428', '2024-12-21 07:38:31.073428', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.4ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------

- so what we want to do to force we need to enforce minimum length requirements for the title and the description.
so for title we want minimum of 6 and maximum of 100 
and for description we will set the minimum of 10 and maximum of 300
-------------------code----------------------
class Article < ApplicationRecord
  validates :title, presence: true, length: { minimum: 6, maximum: 100}
  validates :description, presence: true, length: { minimum: 10, maximum: 300}
end
-------------------code----------------------

and now we test it 
-------------------code----------------------
> article = Article.new(title: "c", description: "d")
=> #<Article:0x0000000108db2a78 id: nil, title: "c", description: "d", created_at: nil, updated_at: nil, publisher: nil>
> article.save!
(rails-app):28:in `<main>': Validation failed: Title is too short (minimum is 6 characters), Description is too short (minimum is 10 characters) (ActiveRecord::RecordInvalid)
> article.errors.full_messages
=> ["Title is too short (minimum is 6 characters)", "Description is too short (minimum is 10 characters)"]
-------------------code----------------------

- if we want to check the more validation we can check "Active Record validation"

*** 5- Show articles (route, action and view) ***
we are going to show the articles in the database to the screen 

step1: create a route
- we go to the config/routes.rb and create our route using the "resources" keyword
this is going to give me all of the routes that I want for articles.
-------------------code---------------------- 
resources :articles
-------------------code----------------------

- to checkout the routes 
1- use command line 
-------------------code----------------------
rails routes --expanded
-------------------code----------------------

2- use the browser by hitting un valid route
-------------------code----------------------
http://localhost:3000/dodo
-------------------code----------------------

- now if we check the result of using the rails route in the console 
we see too much routes we don`t want to use all only the show 
so we use the only keyword
-------------------code----------------------
resources :articles, only: [:show]
-------------------code----------------------

now after the root we can see only the show route 
-------------------code----------------------
--[ Route 3 ]-------------------------------------------------------------------------------------------------------------------------------------------
Prefix            | root
Verb              | GET
URI               | /
Controller#Action | pages#home
Source Location   | rails-app/config/routes.rb:14
--[ Route 4 ]-------------------------------------------------------------------------------------------------------------------------------------------
Prefix            | article
Verb              | GET
URI               | /articles/:id(.:format)
Controller#Action | articles#show
Source Location   | rails-app/config/routes.rb:15
-------------------code----------------------
-------------------code----------------------

- now if we check the URI we see it /articles/:id now let`s try access to the first 
data http://localhost:3000/articles/1
we got error cause we don`t have article controller
-------------------code----------------------
uninitialized constant ArticlesController
Rails.root: rails-app
-------------------code----------------------

- so we can see that our routes is working properly but we don`t have a controller
yet so we create file in the app/controllers/articles_controller.rb
-------------------code----------------------
class ArticleController < ApplicationController

end
-------------------code----------------------

- now we try to access the http://localhost:3000/articles/1 again 
we got 
-------------------code----------------------
Unknown action
The action 'show' could not be found for ArticlesController
-------------------code----------------------

-  so we build show action 
-------------------code----------------------
class ArticlesController < ApplicationController
  def show

  end
end
-------------------code----------------------

- we reload the url http://localhost:3000/articles/1 we got another error 
-------------------code----------------------
ArticlesController#show is missing a template for request formats: text/html
-------------------code----------------------

- so we crete articles folder inside the app/views folder with show.html.erb
and we type heading
-------------------code----------------------
<h1>Showing article details</h1>
-------------------code----------------------

- now if we refresh the page we can see the header

- now our purpose to show the data that related to the id: 1 

- to do that we go back to show action in the controller
so first of all how to find a specific article based on id in our case 1
in rails console we can test that by typing 
-------------------code----------------------
> Article.find(1)
  Article Load (0.2ms)  SELECT "articles".* FROM "articles" WHERE "articles"."id" = 1 LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x0000000111036dc8
 id: 1,
 title: "new title",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-18 10:53:32.363168000 +0000",
 publisher: nil>
-------------------code----------------------

- but if want to do something with the result we should assign to variable
-------------------code----------------------
article = Article.find(1)
  Article Load (0.2ms)  SELECT "articles".* FROM "articles" WHERE "articles"."id" = 1 LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x0000000113133710
...
-------------------code----------------------

- and then we can say something like to display it to the view
-------------------code----------------------
> article.id
=> 1
> article.title
=> "new title"
> article.description
=> "this is the first article"
-------------------code----------------------

- so we need to use this "article = Article.find(the id form the url)"
When I'm entering this ID in the URL, this is getting passed to my application using what's called
the params hash and the params hash sends in the ID in hash format.
to get it we use params hash keyword and grab which parameters we want
-------------------code----------------------
article = Article.find(params[:id])
-------------------code----------------------

- now the column id will have the value of wherever id we entered to the Url 

- at this point we have access to the article variable in the show action so 
technically we should be able to show that in our show view
now before that we need to make our article variable accessible in the show view file 
so we need to change to the instance variable
-------------------code----------------------
class ArticlesController < ApplicationController
  def show
    @article = Article.find(params[:id])
  end
end 
-------------------code----------------------

- now we can use article.title and article.description to display
the contents of the article. 
first we crete p with strong element for each title and description
-------------------code----------------------
<h1>Showing article details</h1>
<p><strong>Title: </strong></p>
<p><strong>Description: </strong></p>
-------------------code----------------------

- now if we try to use our code in the html.erb
-------------------code----------------------
<h1>Showing article details</h1>
<p><strong>Title: </strong>@article.title</p>
<p><strong>Description: </strong>@article.description</p>
-------------------code----------------------

the result we have 
-------------------code----------------------
Showing article details
Title: @article.title

Description: @article.description
-------------------code----------------------

- why?
- cause the code is not evaluated as Ruby code and to make the html.erb read that as code 
we have to use the embedded ruby tags
ps:"<% %>" to evaluate the Ruby code and yet nothing show in the screen 
-------------------code----------------------
<h1>Showing article details</h1>
<p><strong>Title: </strong><% @article.title %></p>
<p><strong>Description: </strong><% @article.description %></p>
-------------------code----------------------
to show it we use the "=<% %>"
-------------------code----------------------
<h1>Showing article details</h1>
<p><strong>Title: </strong><%= @article.title %></p>
<p><strong>Description: </strong><%= @article.description %></p>
-------------------code----------------------


- our code works fine now let`s check how we receive our id in the article controller

we're going to use a tool.
It's called "debug" and our rails application came with it. and we can check the gem file to see it
and what it will do is it'll
pause my web server. and 
-------------------code----------------------
class ArticlesController < ApplicationController
  def show
    
    @article = Article.find(params[:id])
    debugger
  end
end
-------------------code----------------------

and it show us where we are in our code
-------------------code----------------------
1| class ArticlesController < ApplicationController
     2|   def show
     3|
     4|     @article = Article.find(params[:id])
=>   5|     debugger
     6|   end
     7| end
-------------------code----------------------

- now we can see the params 
-------------------code----------------------
(rdbg) params
#<ActionController::Parameters {"controller"=>"articles", "action"=>"show", "id"=>"1"} permitted: false>
-------------------code----------------------

- and the params[:id]
-------------------code----------------------
params[:id]
"1"
-------------------code----------------------

- now to get out from the debugger we use the continue

*** 6-Articles index ***
we will create the article list page by creating the index action

now the same way in the img rails-architecture.png we recheck how the rails works

first: we need to define the index route so first we comment the only section to check what the index 
routes look like 
-------------------code----------------------
resources :articles #, only: [:show]
-------------------code----------------------

- now we type the rails command to check the routes
-------------------code----------------------
rails routes --expanded
-------------------code----------------------

- then search on the index
-------------------code----------------------
--[ Route 4 ]-------------------------------------------------------------------------------------------------------------------------------------------
Prefix            | articles
Verb              | GET
URI               | /articles(.:format)
Controller#Action | articles#index
Source Location   | rails-app/config/routes.rb:15
-------------------code----------------------


- we can see that the Controller#Action is index and the URL to access it is /articles

- now we add to the only the index keyword
-------------------code----------------------
resources :articles , only: [:index, :show]
-------------------code----------------------

- now rails will expect the index action in our controller
so we create the index action 
-------------------code----------------------
def index
    
end
-------------------code----------------------

- next rails expect that there is view/articles/index.html.erb so we created
and the same as show.html.erb we create a header with h1
-------------------code----------------------
<h1>Articles list pages</h1>
-------------------code----------------------

- next we start our server and access 
-------------------code----------------------
http://localhost:3000/articles
-------------------code----------------------

now we can`t see the data cause the index action is empty
so to grab all the articles we use same as rails console
so in rails console 
and then we can iterate through each one using a dot each code.
-------------------code----------------------
> Article.all
  Article Load (4.5ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<Article:0x000000010e190578
  id: 1,
  title: "new title",
  description: "this is the first article",
  created_at: "2024-12-17 10:56:55.496899000 +0000",
  updated_at: "2024-12-18 10:53:32.363168000 +0000",
  publisher: nil>,
 #<Article:0x000000010e4d8d48
  id: 2,
  title: "second article",
  description: "this is the second article",
  created_at: "2024-12-17 12:31:51.612805000 +0000",
  updated_at: "2024-12-17 12:31:51.612805000 +0000",
  publisher: nil>,
 #<Article:0x000000010e4d8c08
  id: 5,
  title: "test",
  description: "test description",
  created_at: "2024-12-21 07:36:28.069685000 +0000",
  updated_at: "2024-12-21 07:36:28.069685000 +0000",
  publisher: nil>,
 #<Article:0x000000010e4d8ac8
  id: 6,
  title: "a",
  description: "b",
  created_at: "2024-12-21 07:38:31.073428000 +0000",
  updated_at: "2024-12-21 07:38:31.073428000 +0000",
  publisher: nil>]
-------------------code----------------------

- in the index action we create @articles (plural cause we save inside it multi articles)instance 
PS: this needs to be an instance variable here because we need it available in our views.
-------------------code----------------------
def index
  @articles = Article.all
end
-------------------code----------------------

- next we create a table in our view to display the data of all articles
"table>thead>tr>th*3"
-------------------code----------------------
<table>
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
</table>
-------------------code----------------------

- we fill it 
-------------------code----------------------
<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Description</th>
      <th>Actions</th>
    </tr>
  </thead>
</table>
-------------------code----------------------
then under the thead we create 
"tbody>tr>td*3"
-------------------code----------------------
<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Description</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
-------------------code----------------------

- then we use the each method 
PS: with for or each method we use "<% %>" and with showing the data we use 
"=<% %>"
-------------------code----------------------
<tbody>
  <% @articles.each do |article| %>
    <tr>
    <td><%= article.title %></td>
    <td><%= article.description %></td>
    <td>PlaceHolder</td>
  </tr>
  <% end %>
</tbody>
-------------------code----------------------

*** 7-Forms - build a new article creation form ***
we will create an article form with title and description

- first in the routes.rb we will add new and create 
-------------------code----------------------
resources :articles , only: [:index, :show, :new, :create]
-------------------code----------------------

******************************************************************************************************
New Vs Create Action:
New Action: 
Purpose: The new action is used to display a form for creating a new resource. It does not actually create the resource in the database.
HTTP Method: Typically responds to a GET request.
View: It renders a view (e.g., new.html.erb) that contains the form for the user to fill out.

Create:
Purpose: The create action is responsible for processing the form submission and actually creating the new resource in the database.
HTTP Method: Typically responds to a POST request.
Form Submission: When the form from the new action is submitted, it sends the data to the create action.
Saving the Object: In the create action, you take the parameters from the form, build a new object, and attempt to save it to the database 
Redirect or Render: After attempting to save, you usually redirect to another action (like index or show) if successful, or render the new view again if there are validation errors.

Summary
new: Displays the form for creating a new resource.
create: Processes the form submission and creates the resource in the database.
******************************************************************************************************



- we check the routes 
-------------------code----------------------
rails routes --expanded
-------------------code----------------------

- we have this new actions in our routes
-------------------code----------------------
--[ Route 5 ]-------------------------------------------------------------------------------------------------------------------------------------------
Prefix            |
Verb              | POST
URI               | /articles(.:format)
Controller#Action | articles#create
Source Location   | rails-app/config/routes.rb:15
--[ Route 6 ]-------------------------------------------------------------------------------------------------------------------------------------------
Prefix            | new_article
Verb              | GET
URI               | /articles/new(.:format)
Controller#Action | articles#new
Source Location   | rails-app/config/routes.rb:15
-------------------code----------------------

- next we build this two actions
-------------------code----------------------
def new

end

def create

end
-------------------code----------------------


- new we create our views new.html.erb
-------------------code----------------------
<h1>Create a new Article</h1>
-------------------code----------------------
PS: in Rails, you typically create .html.erb view files for actions that respond to GET requests

Summary
GET Actions: Have corresponding .html.erb view files to render HTML.
POST, PATCH, and DELETE Actions: Do not have separate view files; they process data from forms submitted from other views.
This structure helps maintain a clear separation of concerns in your Rails application, ensuring that each action has a specific purpose and that views are only created for actions that need to render HTML content.

- now we run our server and access to the 
-------------------code----------------------
http://localhost:3000/articles/new
-------------------code----------------------

- next we create the form to that we can go rails guide 
https://guides.rubyonrails.org/form_helpers.html

-  will use form_with 
PS: according the the rails guide rails8
Before form_with was introduced in Rails 5.1 its functionality was split between form_tag and form_for. Both are now discouraged in favor of form_with, 
but you can still find being used in some codebases.

- now we use the form_with according to the rails guide
-------------------code----------------------
<%= form_with model: @book do |form| %>
  <div>
    <%= form.label :title %>
    <%= form.text_field :title %>
  </div>
  <div>
    <%= form.label :author %>
    <%= form.text_field :author %>
  </div>
  <%= form.submit %>
<% end %>
-------------------code----------------------

now if we go to http://localhost:3000/articles/new we got error 
-------------------code----------------------
ails-app/app/views/articles/new.html.erb where line #2 raised:

Passed nil to the :model argument, expect an object or false
Extracted source (around line #2):

              
<h1>Create a new Article</h1>
<%= form_with model: @article do |form| %>
  <div>
    <%= form.label :title %>
    <%= form.text_field :title %>
  </div>
-------------------code----------------------

cause @article is not defined in the articles controller
so we add it 
in rails console we we create instance by using Article.new
so in the controller we add
-------------------code----------------------
def new
  @article = Article.new
end
-------------------code----------------------

- now to make our add <br/> to give our form a space 
-------------------code----------------------
<h1>Create a new Article</h1>
<%= form_with model: @article do |form| %>
  <div>
    <%= form.label :title %>
    <br/>
    <%= form.text_field :title %>
    
  </div>
  <br/>
  <div>
    <%= form.label :description %>
    <br/>
    <%= form.text_field :description %>
  </div>
  <br/>
  <%= form.submit %>
<% end %>
-------------------code----------------------


- now let`s try to save this form by creating an example data
and we click on "save Article" nothing happens
and if we check the server we can see it starting post 
-------------------code----------------------
Started POST "/articles" for ::1 at 2024-12-28 15:17:17 +0900
Processing by ArticlesController#create as TURBO_STREAM
  Parameters: {"authenticity_token"=>"[FILTERED]", "article"=>{"title"=>"test", "description"=>"test"}, "commit"=>"Create Article"}
No template found for ArticlesController#create, rendering head :no_content
Completed 204 No Content in 29ms (ActiveRecord: 0.0ms (0 queries, 0 cached) | GC: 0.0ms)
-------------------code----------------------

- but we have 
-------------------code----------------------
No template found for ArticlesController#create, rendering head :no_content
-------------------code----------------------

- cause it submitting to our create action but the create action does`nt have any code inside it
now we will use "debugger" to stop the server at the create and inspect 
-------------------code----------------------
def create
   debugger
end
-------------------code----------------------  

- now we press the "create Article" again
the server stop and if we write the params we can see 
-------------------code----------------------  
#<ActionController::Parameters {"authenticity_token"=>"oTBjWdSXmgGYcNYuBLI67S6m-T5zKw_i_7mgHKK2KO_NSGqaMdhKOfXNCo8vUtXr3ZJqgI47dcWqs1W9xHgucw", "article"=>{"title"=>"test", "description"=>"test"}, "commit"=>"Create Article", "controller"=>"articles", "action"=>"create"} permitted: false>
-------------------code----------------------  

- and now we can see the data which is post to the server 
-------------------code----------------------  
params[:article]
#<ActionController::Parameters {"title"=>"test", "description"=>"test1"} permitted: false>
-------------------code----------------------

*** 8-Create action - save newly created articles ***
now what we do is to save the value of the params of article to the database
now tha value of the params[:article] is 
-------------------code----------------------
{"title"=>"test", "description"=>"test1"}
-------------------code----------------------

if we go to rails console we can type like
-------------------code---------------------- 
article = Article.new({"title"=>"test", "description"=>"test1"})
-------------------code----------------------

- now if check the article it save to the memory correctly
-------------------code----------------------
> article
=> #<Article:0x0000000109c76ff0 id: nil, title: "test", description: "test1", created_at: nil, updated_at: nil, publisher: nil>
-------------------code----------------------

now we can do the same thing with our action
instead of article we use @article 
and instead of {"title"=>"test", "description"=>"test1"} we use params[:article]
-------------------code----------------------
def create
  @article = Article.new(params[:article])
end
-------------------code----------------------

- now if we try on the form to press create Article after set the the values
we got error 
-------------------code----------------------
ActiveModel::ForbiddenAttributesError
-------------------code----------------------

- cause what we called strong parameter in rails 
-------------------code----------------------
strong parameters is a feature that helps prevent mass assignment vulnerabilities by requiring you to explicitly specify which parameters are allowed to be used in your model. This is particularly important when dealing with user input, as it helps ensure 
that only the expected attributes are permitted for mass assignment.

1. Mass Assignment Vulnerability: Before strong parameters, Rails allowed mass assignment of attributes, which could lead to security issues if a user could modify attributes that they shouldn't have access to (e.g., admin flags, role attributes, etc.).
2. Permitting Parameters: With strong parameters, you define a method in your controller that specifies which parameters are allowed. This is done using the permit method.
3. Usage: Strong parameters are typically used in the create and update actions of your controllers to ensure that only the specified attributes are allowed to be saved to the database.

Benefits of Strong Parameters
1- Security: By explicitly permitting parameters, you reduce the risk of mass assignment vulnerabilities.
2- Clarity: It makes your code clearer by showing which parameters are expected and allowed for each action.
3- Maintainability: If you need to change which parameters are allowed, you can do so in one place (the strong parameters method).

Summary
Strong parameters are an essential part of Rails applications that help ensure the security and integrity of your data by requiring explicit permission for mass assignment of model attributes. This feature is a best practice in Rails development and is crucial for building secure applications.
-------------------code----------------------

- so to apply user to send this data to the database we use the require with the 
model name and we use the permit to allow which parameter to allow to user 
to insert on our database on our case the title and the description
-------------------code----------------------
def create
  @article = Article.new(params.require(:article).permit(:title, :description))
end
-------------------code----------------------

- next to check the @article we use debugger
-------------------code----------------------
def create
  @article = Article.new(params.require(:article).permit(:title, :description))
  debugger
end
-------------------code----------------------

- and we can see we got an article object
-------------------code----------------------
(ruby) @article
#<Article:0x000000011a45ac98 id: nil, title: "test", description: "test1", created_at: nil, updated_at: nil, publisher: nil>
-------------------code----------------------

- we can see the id is nil which means the data is in the memory but not saved to the 
database yet so we  save the article
-------------------code----------------------
def create
  @article = Article.new(params.require(:article).permit(:title, :description))
  @article.save
end
-------------------code----------------------


- now if jump out to our console we can see it created 
we can see the last record in the database
-------------------code----------------------
Article.last
  Article Load (0.9ms)  SELECT "articles".* FROM "articles" ORDER BY "articles"."id" DESC LIMIT 1 /*application='RailsApp'*/
=>
#<Article:0x0000000106594898
 id: 12,
 title: "Title 1234",
 description: "Description 1234",
 created_at: "2024-12-28 07:46:47.607347000 +0000",
 updated_at: "2024-12-28 07:46:47.607347000 +0000",
 publisher: nil>
-------------------code----------------------

- now after the saving nothing is happens on the screen  
now after the saving we want it to go to another page to do the we use the "redirect_to" + the path to that 
page 
in our case we want to go the show  so using the routes command 
-------------------code----------------------
Prefix            | article
Verb              | GET
URI               | /articles/:id(.:format)
Controller#Action | articles#show
Source Location   | rails-app/config/routes.rb:15
-------------------code----------------------

- and we see the prefix which means if we want to use the prefix we have to article with the path keyword
-------------------code----------------------
article_path
-------------------code----------------------

- so the create action become like this 
-------------------code----------------------
def create
  @article = Article.new(params.require(:article).permit(:title, :description))
  if @article.save
    redirect_to article_path(@article)
  end
end
-------------------code----------------------

So what Rails is going to do is extract the ID from this at article object @article.
This article instance variable, and then use it to form the path.
so it will be for an example redirect_to article_path(23) 23 is the id of the created article

and there is a shortcut instead of using article_path(@article) we can use @article only 
and test our code 
-------------------code----------------------
def create
  @article = Article.new(params.require(:article).permit(:title, :description))
  if @article.save
    redirect_to @article
  end
end
-------------------code----------------------

- until now the code works properly, but we have one problem if the data 
that we submit the form has validation error it will not show to user the why is not saved

*** 9-Messaging - validation and flash messages ***
- now we want  to show the validation error if there is an error
now inside the console we try to create invalid data
-------------------code----------------------  
> article = Article.new(title: "1", description: "2")
=> #<Article:0x00000001059adb38 id: nil, title: "1", description: "2", created_at: nil, updated_at: nil, publisher: nil>
> article.save
=> false
-------------------code----------------------

- we can see the message using the errors.full_messages
-------------------code----------------------
> article.errors.full_messages
=> ["Title is too short (minimum is 6 characters)", "Description is too short (minimum is 10 characters)"]
-------------------code----------------------

so how we show each one we use each method
-------------------code----------------------
> article.errors.full_messages.each do |msg|
*   puts msg
> end
Title is too short (minimum is 6 characters)
Description is too short (minimum is 10 characters)
=> ["Title is too short (minimum is 6 characters)", "Description is too short (minimum is 10 characters)"]
-------------------code----------------------

- so we use the same pattern in our new.html.erb
-------------------code----------------------
<% if @article.errors.any? %>
 <h2>The following errors prevent the article from being saved</h2>
 <ul>
  <% @article.errors.full_messages.each do |msg| %>
   <li><%= msg %></li>
  <% end %>
 </ul>
<% end %>
-------------------code----------------------


- now we test our code 

- last thing we set flash of notice of the article is created 
-------------------code----------------------
def create
  @article = Article.new(params.require(:article).permit(:title, :description))
  if @article.save
    flash[:notice] = "Article was created successfully"
    redirect_to @article
  else 
    render :new
  end
end
-------------------code----------------------

- and sense we want to show the flash in all our pages so we cgo to the layout/application.html.erb
-------------------code----------------------
<body>
  <% flash.each do |name, msg| %>
    <%= msg %>
  <% end %>
  <%= yield %>
</body>
-------------------code----------------------

*** 10-Edit and update: update existing articles ***
now we will edit an exist record using edit and update actions 

- first we need to add edit and update routes
-------------------code----------------------
resources :articles , only: [:index, :show, :new, :create, :edit, :update]
-------------------code----------------------

- using the rails routes --expanded we can check the edit and update routes
for edit route we can see the method is get so it will display the data on our browser

-------------------code----------------------
--[ Route 7 ]-------------------------------------------------------------------------------------------------------------------------------------------
Prefix            | edit_article
Verb              | GET
URI               | /articles/:id/edit(.:format)
Controller#Action | articles#edit
Source Location   | rails-app/config/routes.rb:15
--[ Route 9 ]-------------------------------------------------------------------------------------------------------------------------------------------
Prefix            |
Verb              | PATCH
URI               | /articles/:id(.:format)
Controller#Action | articles#update
Source Location   | rails-app/config/routes.rb:15
--[ Route 10 ]------------------------------------------------------------------------------------------------------------------------------------------
Prefix            |
Verb              | PUT
URI               | /articles/:id(.:format)
Controller#Action | articles#update
Source Location   | rails-app/config/routes.rb:15
-------------------code----------------------


- now we check the edit routes 
/articles/:id/edit and replace the id with an existed id in our database 
-------------------code----------------------
http://localhost:3000/articles/1/edit
-------------------code----------------------

- we got so the route is working
-------------------code----------------------
The action 'edit' could not be found for ArticlesController
-------------------code----------------------

- for the update according to the newest Rails standards, PATCH is used to update the record, while PUT is also available but less commonly used for this purpose.

******************************************************************************************************
PUT vs PATCH
1. Definition:
PUT: The PUT method is used to update a resource by replacing it entirely with the new representation provided in the request. If the resource does not exist, it can create a new resource at the specified URI.
PATCH: The PATCH method is used to apply partial modifications to a resource. It updates only the fields that are specified in the request body, leaving the other fields unchanged.
2. Usage:
PUT:
Typically used when you want to replace an entire resource.
Example: If you have a user object with fields like name, email, and age, a PUT request would require you to send all these fields even if only one of them has changed.
PATCH:
Used when you want to update only specific fields of a resource.
Example: If you only want to update the email of a user, you can send a PATCH request with just the email field.
Idempotency:
PUT: PUT is idempotent, meaning that making the same PUT request multiple times will have the same effect as making it once. If you send the same data again, it will not change the resource further.
PATCH: PATCH is also idempotent, but it can be non-idempotent depending on the implementation. For example, if a PATCH request increments a value, sending it multiple times will yield different results.
Request Body:
PUT: Requires the complete representation of the resource in the request body.
PATCH: Requires only the fields that need to be updated in the request body.
Example:
PUT Example:
-------------------code----------------------
 PUT /users/1
  Content-Type: application/json

  {
    "name": "John Doe",
    "email": "john@example.com",
    "age": 30
  }
-------------------code----------------------

PATCH Example:
-------------------code----------------------
  PATCH /users/1
  Content-Type: application/json

  {
    "email": "john.doe@example.com"
  }
-------------------code----------------------

Summary:
Use PUT when you want to replace an entire resource.
Use PATCH when you want to make partial updates to a resource.
******************************************************************************************************



- now we add the edit action (the action order the action with get method up and POST and PUT/PATCH and DELETE is down )
-------------------code----------------------
def edit

end

def update 

end
-------------------code----------------------

- now if go to the 
-------------------code----------------------
http://localhost:3000/articles/1/edit
-------------------code----------------------

- we have error 
-------------------code----------------------
ArticlesController#edit is missing a template for request formats: text/html
-------------------code----------------------

- so we go to create the views/articles/edit_html.erb
and it will be similar to our new_html.erb form so we will copy it and change only the title

-------------------code----------------------
<h1>Edit a new Article</h1>
<% if @article.errors.any? %>
  <h2>The following errors prevented the article from being saved</h2>
  <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
  </ul>
<% end %>

<%= form_with model: @article do |form| %>
  <div>
    <%= form.label :title %>
    <br/>
    <%= form.text_field :title %>
    
  </div>
  <br/>
  <div>
    <%= form.label :description %>
    <br/>
    <%= form.text_field :description %>
  </div>
  <br/>
  <%= form.submit %>
<% end %>
-------------------code----------------------


- and now if we reload the page 
-------------------code----------------------
http://localhost:3000/articles/1/edit
-------------------code----------------------

-  we got 
-------------------code----------------------
undefined method `errors' for nil:NilClass
Extracted source (around line #2):

              
<h1>Edit a new Article</h1>
<% if @article.errors.any? %>
  <h2>The following errors prevented the article from being saved</h2>
  <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
-------------------code----------------------

- cause we need to define an article 
in the rails console we want to look for an record 
we type article = Article.find(i) 
so we do the same thing in our controller
-------------------code----------------------
def edit
  @article = Article.find(params[:id])
end
-------------------code----------------------

- now we if click on the button Update article nothing happens cause the 
update action is empty and we can see that in our rails server 
-------------------code----------------------
No template found for ArticlesController#update, rendering head :no_content
Completed 204 No Content in 40ms (ActiveRecord: 0.0ms (0 queries, 0 cached) | GC: 0.0ms)
-------------------code----------------------

- now we debug our update action to see how we can write it
-------------------code----------------------
def update 
  debugger
end
-------------------code----------------------

now if check the params 
-------------------code----------------------
roller.rb
    26|       render :new
    27|     end
    28|   end
    29|
    30|   def update
=>  31|     debugger
    32|   end
    33| end
=>#0	ArticlesController#update at ~/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-2:CRUD-Operations-in-Ruby-on-Rails/rails-app/app/controllers/articles_controller.rb:31
  #1	ActionController::BasicImplicitRender#send_action(method="update", args=[]) at ~/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/actionpack-8.0.1/lib/action_controller/metal/basic_implicit_render.rb:8
  # and 76 frames (use `bt' command for all frames)
(rdbg) params
#<ActionController::Parameters {"_method"=>"patch", "authenticity_token"=>"7jz2GPM-2mkKShKu04iUOz6zvxEhhnZsBfJb-v2P7aBi9FwZ05-7w2KNZA8b8MpKM5HxFjRJBtpe1Q5SY4WB9A", "article"=>{"title"=>"update title ", "description"=>"update Description"}, "commit"=>"Update Article", "controller"=>"articles", "action"=>"update", "id"=>"1"} permitted: false>
-------------------code----------------------

- we can see the the value of params is the updated values

- now to apply this new values to our database first we get this record using the id 
-------------------code----------------------
def update 
    @article = Article.find(params[:id])
    debugger
end
-------------------code----------------------

we can test in the debugger
-------------------code----------------------
(ruby) @article = Article.find(params[:id])
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" WHERE "articles"."id" = 1 LIMIT 1 /*action='update',application='RailsApp',controller='articles'*/
   (rdbg)//Users/mahmouddabbbagh/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-2:CRUD-Operations-in-Ruby-on-Rails/rails-app/app/controllers/articles_controller.rb:1:in `update'
#<Article:0x000000010697d658
 id: 1,
 title: "new title",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-18 10:53:32.363168000 +0000",
 publisher: nil>
-------------------code----------------------

- next we use the update method and same as create action we use the permit method 
-------------------code----------------------
@article.update(params.require(:article).permit(:title, :description))
-------------------code----------------------

- next we add it between if statement to see if the record is updated else we return 
to the current page which is edit 
-------------------code----------------------
def update 
    @article = Article.find(params[:id])
    if @article.update(params.require(:article).permit(:title, :description))
      flash[:notice] = "Article was updated successfully"
      redirect_to @article
    else 
      flash[:alert] = "Article updated failed"
      render :edit
    end
  end
-------------------code----------------------


*** 11- Delete: delete articles ***
we will delete an existing record by using the destroy action 
in the route we add destroy route 
-------------------code----------------------
resources :articles , only: [:index, :show, :new, :create, :edit, :update, :destroy]
-------------------code----------------------

but now we have all the related resources of restful api (7 routes)to article so we no longer need the only keyword
-------------------code----------------------
resources :articles
-------------------code----------------------


******************************************************************************************************
A RESTful API (Representational State Transfer API) is a web service that adheres to the principles of REST architecture, which is an architectural style for designing networked applications. 
RESTful APIs use standard HTTP methods and are designed to be stateless, scalable, and cacheable.
Here are the key concepts and characteristics of RESTful APIs:
Key Concepts of RESTful APIs
1. Resources:
In REST, everything is considered a resource, which can be any entity such as users, articles, products, etc. Each resource is identified by a unique URI (Uniform Resource Identifier).

2. HTTP Methods: (CRUD Action)
RESTful APIs use standard HTTP methods to perform operations on resources:
GET: Retrieve a resource or a collection of resources.
POST: Create a new resource.
PUT: Update an existing resource or create it if it does not exist.
PATCH: Partially update an existing resource.
DELETE: Remove a resource.

3. Statelessness:
Each request from a client to a server must contain all the information needed to understand and process the request. The server does not store any client context between requests, making the API stateless.
Representation:
Resources can have multiple representations, such as JSON, XML, or HTML. Clients interact with resources through these representations, typically using JSON for web APIs.

5. Uniform Interface:
RESTful APIs have a uniform interface that simplifies and decouples the architecture, allowing different clients to interact with the API in a consistent manner. This includes using standard HTTP methods, status codes, and media types.

6.Stateless Communication:
Each request is independent, and the server does not retain any session information. This allows for better scalability and reliability.

7. Cacheable:
Responses from the server can be marked as cacheable or non-cacheable, allowing clients to cache responses to improve performance and reduce server load.

Example of RESTful API Endpoints
Using the routes defined in your provided code snippet, heres how a RESTful API for articles might look:
GET /articles: Retrieve a list of articles.
GET /articles/:id: Retrieve a specific article by ID.
POST /articles: Create a new article.
PUT /articles/:id: Update an existing article by ID.
PATCH /articles/:id: Partially update an existing article by ID.
DELETE /articles/:id: Delete an article by ID.

Benefits of RESTful APIs
- Scalability: Statelessness and the use of standard protocols make RESTful APIs highly scalable.
- Flexibility: Clients can interact with the API in various ways, and the API can evolve without breaking existing clients.
- Interoperability: RESTful APIs can be consumed by any client that understands HTTP, making them platform-independent.
- Simplicity: The use of standard HTTP methods and status codes simplifies the design and implementation of APIs.

Conclusion
RESTful APIs are widely used in web development due to their simplicity, scalability, and flexibility. They allow different systems to communicate over the web in a standardized way, making it easier to build and integrate applications.
******************************************************************************************************

- now we create the destroy action 
we will find this article and destroy it then redirect to the index page
-------------------code----------------------
def destroy
  @article = Article.find(params[:id])
  @article.destroy
  redirect_to articles_path
end
-------------------code----------------------

- next we want to add link to the index page next to each article 
that integrate with destroy action
-------------------code----------------------
td><%= article.title %></td>
<td><%= article.description %></td>
<td><%= link_to "Delete", "#" %></td>
-------------------code----------------------

- if hover the mouse on the Delete link we can see in the left down of the screen 
-------------------code----------------------
http://localhost:3000/articles#
-------------------code----------------------

- so we need to set that to the destroy action URL  
-------------------code----------------------
<td><%= link_to "Delete", article_path(article) %></td>
-------------------code----------------------

now if we hover on it we see the url like this 
-------------------code----------------------
http://localhost:3000/articles/1
-------------------code----------------------

- and if we click it it well take us to the show page of that record
why ?
cause the URI of the show and delete routes are the same 
-------------------code----------------------
URI               | /articles/:id(.:format) 
-------------------code----------------------
- so we fix that by adding the Verb (HTTP Method)

-------------------code----------------------
<td><%= button_to "Delete", article_path(article), method: :delete %></td>
-------------------code----------------------
PS: we add button_to cause delete method only works with button_to  


- and now we add the show link 
-------------------code----------------------
<td><%= link_to "Show", article_path(article) %></td>
<td><%= button_to "Delete", article_path(article), method: :delete %></td>
-------------------code----------------------

- finally we add the link back to the show.html.erb
-------------------code----------------------
<h1>Showing article details</h1>
<p><strong>Title: </strong><%= @article.title %></p>
<p><strong>Description: </strong><%= @article.description %></p>
<p><%= link_to "Back", articles_path %></p>
-------------------code----------------------


