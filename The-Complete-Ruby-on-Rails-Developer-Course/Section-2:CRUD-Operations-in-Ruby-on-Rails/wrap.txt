*** 1-Tables, migrations and naming conventions ***

- we're going to build these basically the entire
articles resource from scratch so we understand all the code that goes into it.

we will start with article table and article model
Rails naming convention:
Article resource
Model name: article
Article Model file name: article.rb
Article model class name Article

Table: articles
id: called the primary key
title: string have limit with 255 char
description: text has more that 255 char
-------------------code----------------------
id | title | description
1  |  first_article  | description_of_first_description
2  |  second_article | description_of_second_description
3  |  third_article  | description_of_third_description
4  |  fourth_article | description_of_third_description
-------------------code----------------------

- we create our table using so do that we need to create migration file
the name of the migration file should  be something we understand later on and named using Snakecase.
-------------------code----------------------
rails g migration create_articles
-------------------code----------------------

in the terminal we see that it
-------------------code----------------------
invoke  active_record
create    db/migrate/20241214064512_create_articles.rb
-------------------code----------------------

- the file will be created inside the db/migrate folder 
the first part of the file name is  20241214064512 is the timestamp
And Rails will use this to track migration files as they are created. This is the only reason we actually used a generator to create this file instead of creating it by hand.
The ordering of migration files as we create more of them will be very important.

because of the way we named our migration file Create articles, Rails was smart enough to
know that we wanted to create an articles table.
within this define change method that we have, it has the code necessary to create the articles
table pre filled in, but it has no details within this code block.
So what we'll do is we're going to go ahead and add our title attribute within this code.

it crete to us this migration
-------------------code----------------------
class CreateArticles < ActiveRecord::Migration[8.0]
  def change
    create_table :articles do |t|
      t.timestamps
    end
  end
end
-------------------code----------------------

- now we add the data that we need the title
-------------------code----------------------
class CreateArticles < ActiveRecord::Migration[8.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.timestamps
    end
  end
end
-------------------code----------------------


- now we migrate our file
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- in the console we got 
-------------------code----------------------
== 20241214070114 CreateArticles: migrating ===================================
-- create_table(:articles)
   -> 0.0009s
== 20241214070114 CreateArticles: migrated (0.0009s) ==========================
-------------------code----------------------

- now we can check the table detail in the schema file db/schema
what is schema:
auto-generated file that represents the current state of your database schema. 
It is created based on the migrations that have been run in your application. 
-------------------code---------------------- 
ActiveRecord::Schema[8.0].define(version: 2024_12_14_070114) do
  create_table "articles", force: :cascade do |t|
    t.string "title"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
-------------------code----------------------



PS:
Rails will only run migration files that have not been run already.


so if we run the migrate command again
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- nothing happens cause it runs any un run migration files or any new migration files
since the last time we issued this command.

- now at this point 
even if I wanted to change something in this migration file
let`s say we want to add the description
-------------------code---------------------- 
class CreateArticles < ActiveRecord::Migration[8.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :description
      t.timestamps
    end
  end
end
-------------------code----------------------

- now if i run  Rails DB migrate again, nothing happened
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- and if we open the schema file we can see the article table
not updated. 
so why?

- So in this scenario, if we wanted to change an existed migration file what we are going to 
do the rollback
-------------------code----------------------
rails db:rollback
-------------------code----------------------

the migration file has reverting
-------------------code----------------------
== 20241214070114 CreateArticles: reverting ===================================
-- drop_table(:articles)
   -> 0.0012s
== 20241214070114 CreateArticles: reverted (0.0020s) ==========================
-------------------code----------------------

and if we open the schema file we see it became empty
-------------------code----------------------
ActiveRecord::Schema[8.0].define(version: 0) do
end
-------------------code----------------------

and then change the file 
finally rerun 
-------------------code----------------------
rails db:migrate
-------------------code----------------------

we can see the schema file is updated
-------------------code----------------------
ActiveRecord::Schema[8.0].define(version: 2024_12_14_070114) do
  create_table "articles", force: :cascade do |t|
    t.string "title"
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end

-------------------code----------------------

PS: is not the preferred way to do that, basically in rails we don`t change an existed 
migration file after created it

And there are a few reasons.
And there are several reasons for this.
One key reason is that you will likely collaborate with team members, sharing code repositories. Migration files will run on their machines as well.
If a team member pulls the latest changes, including updates to a previous migration, those changes won't reflect in their database since that migration has already been executed on their system.
This can lead to codebases being out of sync, which is why modifying existing migration files is discouraged.

so instead always create 
Instead, always create a new migration file for any database changes. 
This way, when a team member downloads the latest code, the new changes will be reflected in the new migration file. 
When they run `rails db:migrate`, it will apply the updates instead of ignoring an earlier modified migration file.

- let`s say we want to publisher felid

- we create new migration file and give it name that relevant "add_publisher_to_articles"
-------------------code----------------------
rails g migration add_publisher_to_articles
-------------------code----------------------

- now rails didn`t know which changes to do it create custom migrate file with change method 
early cause we prefix the migration file with create the rails knows that we want to create table 
so the migration file start with create table but now it dose`t  know so we have only change method
-------------------code----------------------
class AddPublisherToArticles < ActiveRecord::Migration[8.0]
  def change
  end
end
-------------------code----------------------

- now we add the "add_column" method to add column to an existed table and the first argument 
to provide will be the table name and the second attribute will be the column name and the third attribute 
will be the column name and the forth attribute will be the data type
-------------------code----------------------
class AddPublisherToArticles < ActiveRecord::Migration[8.0]
  def change
    add_column :articles, :publisher, :string 
  end
end
-------------------code----------------------

- now we new migration file that has not run before to check that we use the 
-------------------code----------------------
rails db:migrate:status
-------------------code----------------------

- We see "up" and "down" next to each migration file. 
- The command `rails db:migrate` only applies migrations with the status "down".
- To change the status of a migration, we use the rollback command, which sets it to "down".
- After rolling back, we can run `rails db:migrate` again to apply the changes and set the migration status to "up".
- Only migrations with the status "up" are reflected in the schema.
- When we create a new migration file, its initial status is "down" until we apply it.
-------------------code----------------------
database: storage/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20241214070114  Create articles
  down    20241214073037  Add publisher to articles
-------------------code----------------------

- now when the migrate command 
-------------------code----------------------
rails db:migrate
-------------------code----------------------

and the the stats of the migration file we can see it became up 
-------------------code----------------------
database: storage/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20241214070114  Create articles
   up     20241214073037  Add publisher to articles
-------------------code----------------------

and we can see it reflected on the schema
-------------------code----------------------
ActiveRecord::Schema[8.0].define(version: 2024_12_14_073037) do
  create_table "articles", force: :cascade do |t|
    t.string "title"
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.string "publisher"
  end
end
-------------------code----------------------



*** 2-Models and rails console *** 
In the last lesson we created this articles table with the title and description Fields.
Now we need for a way to communicate with this table from our Rails application.

and to do that we use the Models:
Rails naming convention:
Article resource
Model name: article
Article Model file name: article.rb
Article model class name Article

- we create the model file app/models/article.rb or by using the command
-------------------code----------------------
rails g model article
-------------------code----------------------

- but because we created the article migration before we can`t use the command and we need to create it the 
model manually 

- every Model we create 
Every model we create will inherit from this file, which is the application record model file.
and the naming is in camelcase where each word start with capitalized alphabet.
-------------------code----------------------
class Article < ApplicationRecord

end
-------------------code----------------------

that`s means of we but any code in the application_record.rb it will apply for all our model files

- we use the Rails console to communicate with database

- now we test our connection to our data base
by using the model with all method , and it generate a sql query
And the response we got was this empty collection or array like structure from the table, which means
that the connection is working. But there are no articles in my articles table. 
-------------------code----------------------
Article.all
  Article Load (7.0ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=> []
-------------------code----------------------

- now we create record by using the create method
ps the id is auto generated by the server we don`t add it manually
-------------------code----------------------
Article.create(title: "article1", description: "this is the first article")
-------------------code----------------------
- and we got 
-------------------code----------------------
TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (1.9ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('article1', 'this is the first article', '2024-12-17 10:56:55.496899', '2024-12-17 10:56:55.496899', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.5ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=>
#<Article:0x0000000106e37860
 id: 1,
 title: "article1",
 description: "this is the first article",
 created_at: "2024-12-17 10:56:55.496899000 +0000",
 updated_at: "2024-12-17 10:56:55.496899000 +0000",
 publisher: nil>
rails-app(dev)>
-------------------code----------------------
******************************************************************************************************
What is Transaction?

1. Transaction: A transaction is a sequence of one or more SQL operations that are executed as a single unit. Transactions ensure that either all operations are completed successfully or none are applied,
maintaining the integrity of the database.
2. BEGIN: When a transaction starts, it is initiated with a BEGIN statement. 
This marks the beginning of the transaction.

3.COMMIT: After executing the necessary operations (like inserting, updating, or deleting records),
the COMMIT statement is issued. This finalizes the transaction, making all changes made during the transaction permanent in the database.

4.Rollback: If something goes wrong during the transaction (e.g., an error occurs), a ROLLBACK can be issued instead of a commit. This undoes all changes made during the transaction, reverting the database to its previous state.
******************************************************************************************************

- now we got id that generate by the server which is 1
So the first ID was one, there's the title, there's the description, and rails also filled in the
timestamps automatically for us.


- now if we wrote the Article.all we can see our created record 
-------------------code----------------------
rails-app(dev)> Article.all
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<Article:0x000000010504adc0
  id: 1,
  title: "article1",
  description: "this is the first article",
  created_at: "2024-12-17 10:56:55.496899000 +0000",
  updated_at: "2024-12-17 10:56:55.496899000 +0000",
  publisher: nil>]
-------------------code----------------------

- now a better way to create an article
instead of directly calling the class, what I'll do is create a variable article with lowercase
A so it's a variable instead of the class, and then I'll assign it to a new article object.
-------------------code----------------------
article = Article.new
-------------------code----------------------

The value 0x0000000105046f40 is a memory address in hexadecimal format. 
In Ruby, when you create an object (like an instance of the Article class), 
the Ruby interpreter allocates memory for that object and assigns it a unique address in memory.
-------------------code----------------------
=> #<Article:0x0000000105046f40 id: nil, title: nil, description: nil, created_at: nil, updated_at: nil, publisher: nil>
-------------------code----------------------



Now because we have the model rails gives me getters and setters to fill in the attributes that we want
we can do like 
-------------------code----------------------
article.title = "second article"
-------------------code----------------------
and the same for description
-------------------code----------------------
article.description = "this is the second article"
=> "this is the second article"
-------------------code----------------------

- now if we type "article"
we see the id is nill that means the object is not saved to the data base
so it`s still object in the memory and not yet a record in the data base
-------------------code----------------------
rails-app(dev)> article
=>
#<Article:0x0000000105046f40
 id: nil,
 title: "second article",
 description: "this is the second article",
 created_at: nil,
 updated_at: nil,
 publisher: nil>
rails-app(dev)>
-------------------code----------------------

- now we save the object to the db using the "save" command
-------------------code----------------------
rails-app(dev)> article.save
TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (8.4ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('second article', 'this is the second article', '2024-12-17 12:31:51.612805', '2024-12-17 12:31:51.612805', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.4ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------

save vs save!
******************************************************************************************************
save:
Behavior: Attempts to save the object to the database.
Return Value: Returns true if the save is successful and false if it fails (e.g., due to validation errors).
Error Handling: Does not raise an exception on failure. Instead, you can check the object's errors collection to see what went wrong.

save!
Behavior: Also attempts to save the object to the database.
Return Value: Returns true if the save is successful.
Error Handling: Raises an ActiveRecord::RecordInvalid exception if the save fails due to validation errors. This is useful for ensuring that you handle errors explicitly.
******************************************************************************************************

- now if we type Article.all we see two records
-------------------code----------------------
rails-app(dev)> Article.all
  Article Load (0.3ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<Article:0x0000000106f7cd10
  id: 1,
  title: "article1",
  description: "this is the first article",
  created_at: "2024-12-17 10:56:55.496899000 +0000",
  updated_at: "2024-12-17 10:56:55.496899000 +0000",
  publisher: nil>,
 #<Article:0x0000000106f7cbd0
  id: 2,
  title: "second article",
  description: "this is the second article",
  created_at: "2024-12-17 12:31:51.612805000 +0000",
  updated_at: "2024-12-17 12:31:51.612805000 +0000",
  publisher: nil>]
-------------------code----------------------

- now we check our article object we see the id of it became 
2 that`s means it saved to the database
-------------------code----------------------
rails-app(dev)> article
=>
#<Article:0x0000000105046f40
 id: 2,
 title: "second article",
 description: "this is the second article",
 created_at: "2024-12-17 12:31:51.612805000 +0000",
 updated_at: "2024-12-17 12:31:51.612805000 +0000",
 publisher: nil>
-------------------code----------------------


- the third way is 
-------------------code----------------------
article = Article.new(title: "article3", description: "this is the third article")
=> #<Article:0x00000001060c21d0 id: nil, title: "article3", description: "this is the third article", created_at: nil, updated_at: nil, publisher: ...
-------------------code----------------------

- then use the save! method
-------------------code----------------------
rails-app(dev)> article.save!
  TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  Article Create (1.6ms)  INSERT INTO "articles" ("title", "description", "created_at", "updated_at", "publisher") VALUES ('article3', 'this is the third article', '2024-12-17 12:38:41.285133', '2024-12-17 12:38:41.285133', NULL) RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.4ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------

- finally we use our Article.all to check our all records
-------------------code----------------------
rails-app(dev)> Article.all
  Article Load (0.2ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<Article:0x0000000106fdd0c0
  id: 1,
  title: "article1",
  description: "this is the first article",
  created_at: "2024-12-17 10:56:55.496899000 +0000",
  updated_at: "2024-12-17 10:56:55.496899000 +0000",
  publisher: nil>,
 #<Article:0x0000000106fdcf80
  id: 2,
  title: "second article",
  description: "this is the second article",
  created_at: "2024-12-17 12:31:51.612805000 +0000",
  updated_at: "2024-12-17 12:31:51.612805000 +0000",
  publisher: nil>,
 #<Article:0x0000000106fdce40
  id: 3,
  title: "article3",
  description: "this is the third article",
  created_at: "2024-12-17 12:38:41.285133000 +0000",
  updated_at: "2024-12-17 12:38:41.285133000 +0000",
  publisher: nil>]
-------------------code----------------------

