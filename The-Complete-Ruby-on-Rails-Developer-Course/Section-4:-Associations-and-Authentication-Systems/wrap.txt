*** 1- Introduction to section 6: users, associations, ERD and more ***
In this section, we'll work with another resource in our application users and learn about associations.

- normally database will take this Type of structure where we will have multi tables
-------------------code----------------------
Database
+---------+---------+
| table 1 | table 2 |
|---------|---------|
|   Row   |   Row   |
|   Row   |   Row   |
|   Row   |   Row   |
+---------+---------+
| table 3 | table 4 |
|---------|---------|
|   Row   |   Row   |
|   Row   |   Row   |
|   Row   |   Row   |
-------------------code----------------------


- Right now we only have the articles table, and in this section we're going to introduce users.
So we'll have a separate users table to go with our articles table and the users table will look like
this.
-------------------code----------------------
users 
+----+----------+----------------+----------+
| id | username  | email          | password |
+----+----------+----------------+----------+
| 1  |          |                |          |
| 2  |          |                |          |
| 3  |          |                |          |
| 4  |          |                |          |
+----+----------+----------------+----------+
-------------------code----------------------

- Now the association will form between users and articles is that users will create articles, so we'll
need to track which user created which article.

That way we have a creator reference for articles and how would we track this?
- We'll do so by introducing a user ID field in the articles table.
In this field, we'll store the user ID of the user who created each article.
So each row, which signifies each article, will have the user ID column filled in.

-------------------code----------------------
users
+----+------+----------------+----------+
| id | name | email          | password |
+----+------+----------------+----------+
| 1  |      |                |          |
| 2  |      |                |          |
| 3  |      |                |          |
| 4  |      |                |          |
+----+------+----------------+----------+

articles
+----+-------+-------------+----------+--------+
| id | title | description | user_id  |
+----+-------+-------------+----------+--------+
| 1  |       |             |          |
| 2  |       |             |          |
| 3  |       |             |          |
| 4  |       |             |          |
+----+-------+-------------+----------+--------+
-------------------code----------------------

- example Here we can see that Articles one and two have the user ID column filled in with the number two.
From this we can infer that the user with ID of two created the first and second articles.
-------------------code----------------------
users
+----+------+----------------+----------+
| id | name | email          | password |
+----+------+----------------+----------+
| 1  |      |                |          |
| 2  |      |                |          |
| 3  |      |                |          |
| 4  |      |                |          |
+----+------+----------------+----------+

articles
+----+-------+-------------+----------+--------+
| id | title | description | user_id  |
+----+-------+-------------+----------+--------+
| 1  |       |             |     2    |
| 2  |       |             |     2    |
| 3  |       |             |     1    |
| 4  |       |             |     3    |
+----+-------+-------------+----------+--------+
-------------------code----------------------


- So when you look at the articles table, this column, this user ID column is what is known as the "foreign key"
This tracks the IDs of the users, which happen to be the primary key of the users table.
So the ID column in the users table is known as a primary key.


- and this association between users and articles is called a one to many association.
Since one user can create many articles 
in other word each user can then create many articles.

But each article, on the other hand, will only have one creator.
Thus, the one to many, with one being on the user side and many on the articles side.
You can visualize this relationship by using what's called an entity relationship diagram or ERD with

-------------------code----------------------
+----------------+          +----------------+
|     users      |          |    articles     |
+----------------+          +----------------+
| id     int     |          | id     int      |
| username string |          | title  string   |
| email   string  |          | description text |
| password string |          | user_id int     |
+----------------+          +----------------+
          1 |                          * |
            |----------------------------|
-------------------code----------------------

PS: we can use "*" or "n" for the many relationship


we can check any association by looking to rails guide 

*** 2- Create users ***
we will create user table with email and userName fields
-------------------code----------------------
users
+----+------+-------+----------+
| id | username | email |
+----+------+-------+----------+
| 1  |      |       | 
| 2  |      |       |
| 3  |      |       | 
| 4  |      |       |
+----+------+-------+----------+
-------------------code----------------------

by running this command 
-------------------code----------------------
rails g model user
-------------------code----------------------

- we will add the email and username to the migration file
-------------------code----------------------
class CreateUsers < ActiveRecord::Migration[8.0]
  def change
    create_table :users do |t|
      t.string :username
      t.string :email
      t.timestamps
    end
  end
end
-------------------code----------------------


- next we run the migration file 
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- finally we check our schema
-------------------code----------------------
create_table "users", force: :cascade do |t|
    t.string "username"
    t.string "email"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
end
-------------------code----------------------

- cause the g model command created  our model file directly 
we can access the user table using the rails console and create a user 
for test 
-------------------code----------------------
> user = User.new(username: "lili", email: "lili@example.com")
> user.save!
-------------------code----------------------

- and check our users
-------------------code----------------------
> User.all
  User Load (0.2ms)  SELECT "users".* FROM "users" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<User:0x0000000107b8d5c8
  id: 1,
  username: "lili",
  email: "[FILTERED]",
  created_at: "2025-01-02 08:29:04.497277000 +0000",
  updated_at: "2025-01-02 08:29:04.497277000 +0000">]
-------------------code----------------------

*** 3- Add user validations ***
we will add the validations for our User class/model
Validations for User class:
- username must be present and unique, length between 3 and 25 characters
- email must be present and unique, length max of 105 characters
- validate email format using regex (regular expression)


PS:
The ruby regular expression used to match the format of valid email addresses is listed below.
-------------------code----------------------
/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
-------------------code----------------------

- we can go to the rails guide and go to Guide Index and select "Active Record Validations"
https://guides.rubyonrails.org/active_record_validations.html
- and add the validations 
same as using length: { minimum: 3, maximum: 25}, but using "in" the newest approach
-------------------code----------------------
validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i,
  message: "only allow email pattern" }
-------------------code----------------------


- now we test our validations
-------------------code----------------------
> user = User.new
> user.username= "t"
> user.email = "test"
> user.valid?
> user.errors.full_messages
["Username is too short (minimum is 3 characters)",
 "Email only allow email pattern"]
-------------------code----------------------

- now we refactor our code by saving the regex in content 
PS: Constants should be written in all uppercase letters,
with words separated by underscores.
ex:
-------------------code----------------------
MAX_USERS = 100
-------------------code----------------------

- in our case we will save the Email regex and we should put the contents
on the top of the file
-------------------code----------------------   
class User < ApplicationRecord
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i

  validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
  validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: VALID_EMAIL_REGEX,
    message: "only allow email pattern" }
end
-------------------code----------------------

- we can test our regex for ruby by using Rubular
https://rubular.com/


- we grab only between the slashes and test it 

PS: In the context of the regular expression w've provided:
The "i" at the end of the regex pattern is a flag that stands for "case insensitive." 
This means that the regex will match email addresses regardless of whether the letters are uppercase or lowercase.
For example, both example@domain.com and Example@Domain.Com would be considered valid matches against this regex.



*** 4-One to many association ***
as we said before to track the article which belongs to users we should add foreign key to the articles table 

- so first we create migration file using this command 
-------------------code----------------------
rails g migration add_user_id_to_articles
-------------------code----------------------

- bigint VS integer
******************************************************************************************************
- int (Integer):
Size: 4 bytes
Range: -2,147,483,648 to 2,147,483,647
Use Case: Suitable for most applications where values do not exceed the integer range.
- bigint (Big Integer):
Size: 8 bytes
Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
Use Case: Ideal for applications with large datasets or when expecting a high number of records, such as user IDs.
In your migration, using bigint for user_id is appropriate if you anticipate a large number of users.
******************************************************************************************************


- we add the user_id 
-------------------code----------------------
def change
  add_column :articles, :user_id, :bigint
end
-------------------code----------------------

- we run the migration
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- next we add the associations 
in the User model  we add the has_many
-------------------code----------------------
class User < ApplicationRecord
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  has_many :articles

  validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
  validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: VALID_EMAIL_REGEX,
    message: "only allow email pattern" }
end
-------------------code----------------------


and in the user model we add belongs_to user
PS: when we use belongs_to is single so we add "user" not "users" 
-------------------code----------------------
class Article < ApplicationRecord
  belongs_to :user
  
  validates :title, presence: true, length: { in: 6..100 }
  validates :description, presence: true, length: { in: 10..300 }
end
-------------------code----------------------

- now we test our relations 
-------------------code----------------------
> Article.first.update(user_id: 1)
> article = Article.first
> article.user
  User Load (0.3ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1 /*application='RailsApp'*/
=>
#<User:0x000000010a9398a0
 id: 1,
 username: "lili",
 email: "[FILTERED]",
 created_at: "2025-01-02 08:29:04.497277000 +0000",
 updated_at: "2025-01-02 08:29:04.497277000 +0000">
-------------------code----------------------

- now we test it on our screen 
we can`t created article why?
we debug our create action we want to stop the code before saving the article
-------------------code----------------------
def create 
    @article = Article.new(article_params)
    debugger
    if @article.save
      flash[:notice] = "Article was created successfully"
      redirect_to @article
    else 
      flash[:alert] = "Article created failed"
      render :new
    end
  end
-------------------code----------------------

- now we create article and press save 
-------------------code----------------------
Articles_controller.rb
    16|   def edit
    17|   end
    18|
    19|   def create
    20|     @article = Article.new(article_params)
=>  21|     debugger
    22|     if @article.save
    23|       flash[:notice] = "Article was created successfully"
    24|       redirect_to @article
    25|     else
=>#0	ArticlesController#create at ~/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/articles_controller.rb:21
  #1	ActionController::BasicImplicitRender#send_action(method="create", args=[]) at ~/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/actionpack-8.0.1/lib/action_controller/metal/basic_implicit_render.rb:8
-------------------code----------------------

- we check @article and see if it valid 
-------------------code----------------------
(ruby) @article.valid?
false
(ruby) @article.errors.full_messages
["User must exist"]
-------------------code----------------------

- later after setting up the Authentication we will let only the logged in user 
to create an article
but for now we will set all the article to the first users 
PS: if our db is empty of users we will not be able to create any user 
-------------------code----------------------
def create 
  @article = Article.new(article_params)
  @article.user = User.first
  if @article.save
    flash[:notice] = "Article was created successfully"
    redirect_to @article
  else 
    flash[:alert] = "Article created failed"
    render :new
  end
end
-------------------code----------------------

- now we retest our creating article function and we can see it works properly 

- now we need to update the other Article users_id for User.first by using the update_all method
-------------------code----------------------
> Article.update_all(user_id: 1)
  Article Update All (2.9ms)  UPDATE "articles" SET "user_id" = 1 /*application='RailsApp'*/
=> 32
-------------------code----------------------

