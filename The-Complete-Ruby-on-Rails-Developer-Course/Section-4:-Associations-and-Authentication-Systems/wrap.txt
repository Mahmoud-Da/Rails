*** 1- Introduction to section 6: users, associations, ERD and more ***
In this section, we'll work with another resource in our application users and learn about associations.

- normally database will take this Type of structure where we will have multi tables
-------------------code----------------------
Database
+---------+---------+
| table 1 | table 2 |
|---------|---------|
|   Row   |   Row   |
|   Row   |   Row   |
|   Row   |   Row   |
+---------+---------+
| table 3 | table 4 |
|---------|---------|
|   Row   |   Row   |
|   Row   |   Row   |
|   Row   |   Row   |
-------------------code----------------------


- Right now we only have the articles table, and in this section we're going to introduce users.
So we'll have a separate users table to go with our articles table and the users table will look like
this.
-------------------code----------------------
users 
+----+----------+----------------+----------+
| id | username  | email          | password |
+----+----------+----------------+----------+
| 1  |          |                |          |
| 2  |          |                |          |
| 3  |          |                |          |
| 4  |          |                |          |
+----+----------+----------------+----------+
-------------------code----------------------

- Now the association will form between users and articles is that users will create articles, so we'll
need to track which user created which article.

That way we have a creator reference for articles and how would we track this?
- We'll do so by introducing a user ID field in the articles table.
In this field, we'll store the user ID of the user who created each article.
So each row, which signifies each article, will have the user ID column filled in.

-------------------code----------------------
users
+----+------+----------------+----------+
| id | name | email          | password |
+----+------+----------------+----------+
| 1  |      |                |          |
| 2  |      |                |          |
| 3  |      |                |          |
| 4  |      |                |          |
+----+------+----------------+----------+

articles
+----+-------+-------------+----------+--------+
| id | title | description | user_id  |
+----+-------+-------------+----------+--------+
| 1  |       |             |          |
| 2  |       |             |          |
| 3  |       |             |          |
| 4  |       |             |          |
+----+-------+-------------+----------+--------+
-------------------code----------------------

- example Here we can see that Articles one and two have the user ID column filled in with the number two.
From this we can infer that the user with ID of two created the first and second articles.
-------------------code----------------------
users
+----+------+----------------+----------+
| id | name | email          | password |
+----+------+----------------+----------+
| 1  |      |                |          |
| 2  |      |                |          |
| 3  |      |                |          |
| 4  |      |                |          |
+----+------+----------------+----------+

articles
+----+-------+-------------+----------+--------+
| id | title | description | user_id  |
+----+-------+-------------+----------+--------+
| 1  |       |             |     2    |
| 2  |       |             |     2    |
| 3  |       |             |     1    |
| 4  |       |             |     3    |
+----+-------+-------------+----------+--------+
-------------------code----------------------


- So when you look at the articles table, this column, this user ID column is what is known as the "foreign key"
This tracks the IDs of the users, which happen to be the primary key of the users table.
So the ID column in the users table is known as a primary key.


- and this association between users and articles is called a one to many association.
Since one user can create many articles 
in other word each user can then create many articles.

But each article, on the other hand, will only have one creator.
Thus, the one to many, with one being on the user side and many on the articles side.
You can visualize this relationship by using what's called an entity relationship diagram or ERD with

-------------------code----------------------
+----------------+          +----------------+
|     users      |          |    articles     |
+----------------+          +----------------+
| id     int     |          | id     int      |
| username string |          | title  string   |
| email   string  |          | description text |
| password string |          | user_id int     |
+----------------+          +----------------+
          1 |                          * |
            |----------------------------|
-------------------code----------------------

PS: we can use "*" or "n" for the many relationship


we can check any association by looking to rails guide 

*** 2- Create users ***
we will create user table with email and userName fields
-------------------code----------------------
users
+----+------+-------+----------+
| id | username | email |
+----+------+-------+----------+
| 1  |      |       | 
| 2  |      |       |
| 3  |      |       | 
| 4  |      |       |
+----+------+-------+----------+
-------------------code----------------------

by running this command 
-------------------code----------------------
rails g model user
-------------------code----------------------

- we will add the email and username to the migration file
-------------------code----------------------
class CreateUsers < ActiveRecord::Migration[8.0]
  def change
    create_table :users do |t|
      t.string :username
      t.string :email
      t.timestamps
    end
  end
end
-------------------code----------------------


- next we run the migration file 
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- finally we check our schema
-------------------code----------------------
create_table "users", force: :cascade do |t|
    t.string "username"
    t.string "email"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
end
-------------------code----------------------

- cause the g model command created  our model file directly 
we can access the user table using the rails console and create a user 
for test 
-------------------code----------------------
> user = User.new(username: "lili", email: "lili@example.com")
> user.save!
-------------------code----------------------

- and check our users
-------------------code----------------------
> User.all
  User Load (0.2ms)  SELECT "users".* FROM "users" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<User:0x0000000107b8d5c8
  id: 1,
  username: "lili",
  email: "[FILTERED]",
  created_at: "2025-01-02 08:29:04.497277000 +0000",
  updated_at: "2025-01-02 08:29:04.497277000 +0000">]
-------------------code----------------------

*** 3- Add user validations ***
we will add the validations for our User class/model
Validations for User class:
- username must be present and unique, length between 3 and 25 characters
- email must be present and unique, length max of 105 characters
- validate email format using regex (regular expression)


PS:
The ruby regular expression used to match the format of valid email addresses is listed below.
-------------------code----------------------
/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
-------------------code----------------------

- we can go to the rails guide and go to Guide Index and select "Active Record Validations"
https://guides.rubyonrails.org/active_record_validations.html
- and ad the validations 
-------------------code----------------------
validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i,
  message: "only allow email pattern" }
-------------------code----------------------


- now we test our validations
-------------------code----------------------
> user = User.new
> user.username= "t"
> user.email = "test"
> user.valid?
> user.errors.full_messages
["Username is too short (minimum is 3 characters)",
 "Email only allow email pattern"]
-------------------code----------------------

- now we refactor our code by saving the regex in content 
PS: Constants should be written in all uppercase letters,
with words separated by underscores.
ex:
-------------------code----------------------
MAX_USERS = 100
-------------------code----------------------

- in our case we will save the Email regex and we should put the contents
on the top of the file
-------------------code----------------------   
class User < ApplicationRecord
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i

  validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
  validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: VALID_EMAIL_REGEX,
    message: "only allow email pattern" }
end
-------------------code----------------------

- we can test our regex for ruby by using Rubular
https://rubular.com/


- we grab only between the slashes and test it 

PS: In the context of the regular expression w've provided:
The "i" at the end of the regex pattern is a flag that stands for "case insensitive." 
This means that the regex will match email addresses regardless of whether the letters are uppercase or lowercase.
For example, both example@domain.com and Example@Domain.Com would be considered valid matches against this regex.

