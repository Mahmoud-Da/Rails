*** 1- Introduction to section 6: users, associations, ERD and more ***
In this section, we'll work with another resource in our application users and learn about associations.

- normally database will take this Type of structure where we will have multi tables
-------------------code----------------------
Database
+---------+---------+
| table 1 | table 2 |
|---------|---------|
|   Row   |   Row   |
|   Row   |   Row   |
|   Row   |   Row   |
+---------+---------+
| table 3 | table 4 |
|---------|---------|
|   Row   |   Row   |
|   Row   |   Row   |
|   Row   |   Row   |
-------------------code----------------------


- Right now we only have the articles table, and in this section we're going to introduce users.
So we'll have a separate users table to go with our articles table and the users table will look like
this.
-------------------code----------------------
users 
+----+----------+----------------+----------+
| id | username  | email          | password |
+----+----------+----------------+----------+
| 1  |          |                |          |
| 2  |          |                |          |
| 3  |          |                |          |
| 4  |          |                |          |
+----+----------+----------------+----------+
-------------------code----------------------

- Now the association will form between users and articles is that users will create articles, so we'll
need to track which user created which article.

That way we have a creator reference for articles and how would we track this?
- We'll do so by introducing a user ID field in the articles table.
In this field, we'll store the user ID of the user who created each article.
So each row, which signifies each article, will have the user ID column filled in.

-------------------code----------------------
users
+----+------+----------------+----------+
| id | name | email          | password |
+----+------+----------------+----------+
| 1  |      |                |          |
| 2  |      |                |          |
| 3  |      |                |          |
| 4  |      |                |          |
+----+------+----------------+----------+

articles
+----+-------+-------------+----------+--------+
| id | title | description | user_id  |
+----+-------+-------------+----------+--------+
| 1  |       |             |          |
| 2  |       |             |          |
| 3  |       |             |          |
| 4  |       |             |          |
+----+-------+-------------+----------+--------+
-------------------code----------------------

- example Here we can see that Articles one and two have the user ID column filled in with the number two.
From this we can infer that the user with ID of two created the first and second articles.
-------------------code----------------------
users
+----+------+----------------+----------+
| id | name | email          | password |
+----+------+----------------+----------+
| 1  |      |                |          |
| 2  |      |                |          |
| 3  |      |                |          |
| 4  |      |                |          |
+----+------+----------------+----------+

articles
+----+-------+-------------+----------+--------+
| id | title | description | user_id  |
+----+-------+-------------+----------+--------+
| 1  |       |             |     2    |
| 2  |       |             |     2    |
| 3  |       |             |     1    |
| 4  |       |             |     3    |
+----+-------+-------------+----------+--------+
-------------------code----------------------


- So when you look at the articles table, this column, this user ID column is what is known as the "foreign key"
This tracks the IDs of the users, which happen to be the primary key of the users table.
So the ID column in the users table is known as a primary key.


- and this association between users and articles is called a one to many association.
Since one user can create many articles 
in other word each user can then create many articles.

But each article, on the other hand, will only have one creator.
Thus, the one to many, with one being on the user side and many on the articles side.
You can visualize this relationship by using what's called an entity relationship diagram or ERD with

-------------------code----------------------
+----------------+          +----------------+
|     users      |          |    articles     |
+----------------+          +----------------+
| id     int     |          | id     int      |
| username string |          | title  string   |
| email   string  |          | description text |
| password string |          | user_id int     |
+----------------+          +----------------+
          1 |                          * |
            |----------------------------|
-------------------code----------------------

PS: we can use "*" or "n" for the many relationship


we can check any association by looking to rails guide 

*** 2- Create users ***
we will create user table with email and userName fields
-------------------code----------------------
users
+----+------+-------+----------+
| id | username | email |
+----+------+-------+----------+
| 1  |      |       | 
| 2  |      |       |
| 3  |      |       | 
| 4  |      |       |
+----+------+-------+----------+
-------------------code----------------------

by running this command 
-------------------code----------------------
rails g model user
-------------------code----------------------

- we will add the email and username to the migration file
-------------------code----------------------
class CreateUsers < ActiveRecord::Migration[8.0]
  def change
    create_table :users do |t|
      t.string :username
      t.string :email
      t.timestamps
    end
  end
end
-------------------code----------------------


- next we run the migration file 
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- finally we check our schema
-------------------code----------------------
create_table "users", force: :cascade do |t|
    t.string "username"
    t.string "email"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
end
-------------------code----------------------

- cause the g model command created  our model file directly 
we can access the user table using the rails console and create a user 
for test 
-------------------code----------------------
> user = User.new(username: "lili", email: "lili@example.com")
> user.save!
-------------------code----------------------

- and check our users
-------------------code----------------------
> User.all
  User Load (0.2ms)  SELECT "users".* FROM "users" /* loading for pp */ LIMIT 11 /*application='RailsApp'*/
=>
[#<User:0x0000000107b8d5c8
  id: 1,
  username: "lili",
  email: "[FILTERED]",
  created_at: "2025-01-02 08:29:04.497277000 +0000",
  updated_at: "2025-01-02 08:29:04.497277000 +0000">]
-------------------code----------------------

*** 3- Add user validations ***
we will add the validations for our User class/model
Validations for User class:
- username must be present and unique, length between 3 and 25 characters
- email must be present and unique, length max of 105 characters
- validate email format using regex (regular expression)


PS:
The ruby regular expression used to match the format of valid email addresses is listed below.
-------------------code----------------------
/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
-------------------code----------------------

- we can go to the rails guide and go to Guide Index and select "Active Record Validations"
https://guides.rubyonrails.org/active_record_validations.html
- and add the validations 
same as using length: { minimum: 3, maximum: 25}, but using "in" the newest approach
-------------------code----------------------
validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i,
  message: "only allow email pattern" }
-------------------code----------------------


- now we test our validations
-------------------code----------------------
> user = User.new
> user.username= "t"
> user.email = "test"
> user.valid?
> user.errors.full_messages
["Username is too short (minimum is 3 characters)",
 "Email only allow email pattern"]
-------------------code----------------------

- now we refactor our code by saving the regex in content 
PS: Constants should be written in all uppercase letters,
with words separated by underscores.
ex:
-------------------code----------------------
MAX_USERS = 100
-------------------code----------------------

- in our case we will save the Email regex and we should put the contents
on the top of the file
-------------------code----------------------   
class User < ApplicationRecord
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i

  validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
  validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: VALID_EMAIL_REGEX,
    message: "only allow email pattern" }
end
-------------------code----------------------

- we can test our regex for ruby by using Rubular
https://rubular.com/


- we grab only between the slashes and test it 

PS: In the context of the regular expression w've provided:
The "i" at the end of the regex pattern is a flag that stands for "case insensitive." 
This means that the regex will match email addresses regardless of whether the letters are uppercase or lowercase.
For example, both example@domain.com and Example@Domain.Com would be considered valid matches against this regex.



*** 4-One to many association ***
as we said before to track the article which belongs to users we should add foreign key to the articles table 

- so first we create migration file using this command 
-------------------code----------------------
rails g migration add_user_id_to_articles
-------------------code----------------------

- bigint VS integer
******************************************************************************************************
- int (Integer):
Size: 4 bytes
Range: -2,147,483,648 to 2,147,483,647
Use Case: Suitable for most applications where values do not exceed the integer range.
- bigint (Big Integer):
Size: 8 bytes
Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
Use Case: Ideal for applications with large datasets or when expecting a high number of records, such as user IDs.
In your migration, using bigint for user_id is appropriate if you anticipate a large number of users.
******************************************************************************************************


- we add the user_id 
-------------------code----------------------
def change
  add_column :articles, :user_id, :bigint
end
-------------------code----------------------

- we run the migration
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- next we add the associations 
in the User model  we add the has_many
-------------------code----------------------
class User < ApplicationRecord
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  has_many :articles

  validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
  validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: VALID_EMAIL_REGEX,
    message: "only allow email pattern" }
end
-------------------code----------------------


and in the user model we add belongs_to user
PS: when we use belongs_to is single so we add "user" not "users" 
-------------------code----------------------
class Article < ApplicationRecord
  belongs_to :user
  
  validates :title, presence: true, length: { in: 6..100 }
  validates :description, presence: true, length: { in: 10..300 }
end
-------------------code----------------------

- now we test our relations 
-------------------code----------------------
> Article.first.update(user_id: 1)
> article = Article.first
> article.user
  User Load (0.3ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1 /*application='RailsApp'*/
=>
#<User:0x000000010a9398a0
 id: 1,
 username: "lili",
 email: "[FILTERED]",
 created_at: "2025-01-02 08:29:04.497277000 +0000",
 updated_at: "2025-01-02 08:29:04.497277000 +0000">
-------------------code----------------------

- now we test it on our screen 
we can`t created article why?
we debug our create action we want to stop the code before saving the article
-------------------code----------------------
def create 
    @article = Article.new(article_params)
    debugger
    if @article.save
      flash[:notice] = "Article was created successfully"
      redirect_to @article
    else 
      flash[:alert] = "Article created failed"
      render :new
    end
  end
-------------------code----------------------

- now we create article and press save 
-------------------code----------------------
Articles_controller.rb
    16|   def edit
    17|   end
    18|
    19|   def create
    20|     @article = Article.new(article_params)
=>  21|     debugger
    22|     if @article.save
    23|       flash[:notice] = "Article was created successfully"
    24|       redirect_to @article
    25|     else
=>#0	ArticlesController#create at ~/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/articles_controller.rb:21
  #1	ActionController::BasicImplicitRender#send_action(method="create", args=[]) at ~/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/actionpack-8.0.1/lib/action_controller/metal/basic_implicit_render.rb:8
-------------------code----------------------

- we check @article and see if it valid 
-------------------code----------------------
(ruby) @article.valid?
false
(ruby) @article.errors.full_messages
["User must exist"]
-------------------code----------------------

- later after setting up the Authentication we will let only the logged in user 
to create an article
but for now we will set all the article to the first users 
PS: if our db is empty of users we will not be able to create any user 
-------------------code----------------------
def create 
  @article = Article.new(article_params)
  @article.user = User.first
  if @article.save
    flash[:notice] = "Article was created successfully"
    redirect_to @article
  else 
    flash[:alert] = "Article created failed"
    render :new
  end
end
-------------------code----------------------

- now we retest our creating article function and we can see it works properly 

- now we need to update the other Article users_id for User.first by using the update_all method
-------------------code----------------------
> Article.update_all(user_id: 1)
  Article Update All (2.9ms)  UPDATE "articles" SET "user_id" = 1 /*application='RailsApp'*/
=> 32
-------------------code----------------------


*** 5- Show user info in articles ***
we will show the user name of the User to the Articles
we can access the user form article like article.user.username 

in index.html we add Author
-------------------code----------------------
<tr>
  <th>Title</th>
  <th>Description</th>
  <th>Author</th>
  <th colspan="3" >Actions</th>
</tr>
-------------------code----------------------

- and we map the user name 
-------------------code----------------------
<% @articles.each do |article| %>
  <tr>
  <td><%= article.title %></td>
  <td><%= article.description %></td>
  <td><%= article.user.username %></td>
  <td><%= link_to "Show", article_path(article) %></td>
  <td><%= link_to "Edit", edit_article_path(article) %></td>
  <td><%= button_to "Delete", article_path(article), method: :delete, data: { turbo_confirm: "Are you sure you want to delete this article?" } %></td>
</tr>
<% end %>
-------------------code----------------------

- then we add it to show page 
-------------------code----------------------
<p><strong>Title: </strong><%= @article.title %></p>
<p><strong>Description: </strong><%= @article.description %></p>
<p><strong>User: </strong><%= @article.user.username %></p>
-------------------code----------------------


*** 6-Alter object state before_save ***
we will see how to use the before save method and cover how we can change an object's
state right before it saves to the database.

Right now, if you look at the email field, it can have random capitalized letters in it.
But for email addresses we want to save all to lowercase before saving to the database.

- we can check that in the rails console
and we can see it created
-------------------code----------------------
> User.create(username: "Mike",email: "miKesP@example.com" )
 TRANSACTION (0.0ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  User Exists? (0.5ms)  SELECT 1 AS one FROM "users" WHERE "users"."username" = 'Mike' LIMIT 1 /*application='RailsApp'*/
  User Exists? (0.0ms)  SELECT 1 AS one FROM "users" WHERE "users"."email" = 'miKesP@example.com' LIMIT 1 /*application='RailsApp'*/
  User Create (0.1ms)  INSERT INTO "users" ("username", "email", "created_at", "updated_at") VALUES ('Mike', 'miKesP@example.com', '2025-01-02 13:00:06.561071', '2025-01-02 13:00:06.561071') RETURNING "id" /*application='RailsApp'*/
  TRANSACTION (0.1ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=>
#<User:0x00000001075a39c8
 id: 2,
 username: "Mike",
 email: "[FILTERED]",
 created_at: "2025-01-02 13:00:06.561071000 +0000",
 updated_at: "2025-01-02 13:00:06.561071000 +0000">
-------------------code----------------------

- we can turn each email to lowercase before it save to the database 
-------------------code----------------------
before_save { self.email = email.downcase }
-------------------code----------------------


- this "self" is referencing each object of the user class, so when it comes to the email field for any
of these objects before saving it to the database, it runs the Downcase method on that field and then
saves it.
-------------------code----------------------
class User < ApplicationRecord
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  has_many :articles
  
  before_save { self.email = email.downcase }
  validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
  validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: VALID_EMAIL_REGEX,
    message: "only allow email pattern" }
end
-------------------code----------------------

- now we try it again 
-------------------code----------------------
> User.create(username: "Mike3",email: "miKessP@example.com" )

> User.last.email
  User Load (0.3ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" DESC LIMIT 1 /*application='RailsApp'*/
=> "mikessp@example.com"
-------------------code----------------------


*** 7- Add secure password ***
form this lesson we will built authentication from scratch we will use gem called "device"
PS: from rails 8 the authentication will be available within it without using third library 


- first we go to the gems.org 
-------------------code----------------------
https://rubygems.org/
-------------------code----------------------

- search for "device" and we add the gem to our Gemfile
PS: when downloading a gem we should only set the version of that gem 
-------------------code----------------------
gem 'devise', '~> 4.9', '>= 4.9.4'
-------------------code----------------------

- and we add comment 
-------------------code----------------------
# Authentication
gem 'devise', '~> 4.9', '>= 4.9.4'
-------------------code----------------------

- now we have a gem which commented called "bcrypt"
we uncommented
-------------------code----------------------
# Use Active Model has_secure_password [https://guides.rubyonrails.org/active_model_basics.html#securepassword]
gem "bcrypt", "~> 3.1.7"
-------------------code----------------------

- And this is the gem that provides all the security and hashing features that we're going to need.
So how does saving passwords for users actually work and how does it authenticate?

- Let's say I have a users table like this and I have a user with username of monsieur and email of some
email. Now this user needs to add a password to their account so they can sign up for the application.
Let's say they choose the password. => "password123"
-------------------code----------------------
users 
+----+----------+----------------+----------+
| id | username  | email          | password |
+----+----------+----------------+----------+
| 1  | mashrur  | mash@ex..      | password123 |
| 2  |          |                |          |
| 3  |          |                |          |
| 4  |          |                |          |
+----+----------+----------------+----------+
-------------------code----------------------

What Bcrypt is going to do is it's going to hash this password and save a string for ex:
-------------------code----------------------
JPeq6FCbu6ALfYr00Fe
-------------------code----------------------

this is what's known as a "hashed password", and it's a one way hash. which means 
Basically, there's no way to convert this back to "password123"

- How "hashing bit" and "salt" work? 
general idea is if your database is compromised, let's say a hacker gets access to all this
data, they have no way of knowing what your user's username and password or email and password combinations
are so they won't be able to use it to hack into other accounts that the user might have.
So that's the advantage of having a hashed password.


But it's not just enough to have just a simple hash using a hashing algorithm.
hashing algorithms are math and the algorithms and how they work are known. So if the hacker knew what algorithm was being used in a particular authentication system, then you
could have a password such as "password123" put through that hashing algorithm and it
would always give you the same hash so the hacker could try a table of thousands or maybe millions of known words and their hashed versions and look for a match.
And this type of reversal of cryptographic hash functions using such a table is known as a "rainbow attack".
ex:
-------------------code----------------------
password123  →  hashing algorithm  →  MtjV3V5v0LW0
                                      JPeq6FCbu6AL
                                      fYr00Fe

password      →  hashing algorithm  →  Y2SoBecnR7L/
                                      Ou33Q7W4rEz
                                      vS2/FeFi

hello123      →  hashing algorithm  →  66vd8pbp.Gwx
                                      4oDYMoHYltkP
                                      dEIMOS6
-------------------code----------------------


_ So what's the solution to make this type of encryption one way?
the solution is what we called "salt"
salt: is a random piece of text that's added to each password before hashing it.

we will see that using Bcrypt so we install the bundle
-------------------code----------------------
bundle install
-------------------code----------------------

- then we check our Gemfile.lock to see if it installed


- to use Bcrypt we need to add has_secure_password to our User model
-------------------code----------------------
class User < ApplicationRecord
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  has_many :articles
  
  before_save { self.email = email.downcase }
  validates :username, presence: true, uniqueness: true, length: { in: 3..25 }
  validates :email, presence: true, uniqueness: true, length: { maximum: 150 }, format: { with: VALID_EMAIL_REGEX,
    message: "only allow email pattern" }

  has_secure_password
end
-------------------code----------------------


- now we add the password field 
-------------------code----------------------
rails g migration add_password_digest_to_users
-------------------code----------------------

- we called "password_digest" to the User table
-------------------code----------------------
class AddPasswordDigestToUsers < ActiveRecord::Migration[8.0]
  def change
    add_column :users, :password_digest, :string
  end
end
-------------------code----------------------
******************************************************************************************************
why when we use bcrypt gem we need to name the column password_digest?
The bcrypt gem is used in Ruby on Rails to securely hash passwords. When using bcrypt, 
the convention is to name the column that stores the hashed password as password_digest. Here’s why:

1.Convention over Configuration: Rails follows the principle of "convention over configuration," 
which means that it has default behaviors that developers can rely on. By using password_digest, 
Rails can automatically know how to handle password hashing and authentication without requiring additional configuration.

2.Active Model Secure Password: The bcrypt gem integrates with Rails' has_secure_password method, which is part of Active Model. 
This method looks for a column named password_digest to store the hashed password. 
If you use a different name, you would need to override this behavior, which can lead to more complex code and potential errors.

3. Security: The name password_digest clearly indicates that the column contains a hashed version of the password, 
which is a good practice for code readability and security. It helps developers understand the purpose of the column at a glance.

In summary, using password_digest is a convention that simplifies the implementation of secure password handling in Rails applications.

- if we used another name expect password_digest it will not works ?
the has_secure_password method will not work out of the box. This is because has_secure_password specifically looks for a column named password_digest to store the hashed password and to verify the password during authentication.
1. Custom Column Name: You can specify a different column name by using the :column option in the has_secure_password method.
For example, if you want to use hashed_password instead of password_digest, you would do the following:
-------------------code----------------------
class User < ApplicationRecord
  has_secure_password :column => :hashed_password
end
-------------------code----------------------

2.Manual Handling: If you choose to use a different column name without specifying it in has_secure_password, you would need to manually handle the password hashing and verification process,
which can complicate your code and increase the risk of security vulnerabilities.

In summary, while it is possible to use a different column name, it requires additional configuration and can lead to more complex code.
Sticking with the convention of password_digest is recommended for simplicity and security.
******************************************************************************************************

- we migrate the changes
-------------------code----------------------
rails db:migrate
-------------------code----------------------

- now we can test Bcrypt in rails console
-------------------code----------------------
> BCrypt::Password.create("password")
=> "$2a$12$96zNwE5bsABseZbupdpy3OLKrve4dFaDDopXXPPbgllFIp/b6fiO6"
-------------------code----------------------

- now we had hashed password
but what if we do it again 
-------------------code----------------------
> BCrypt::Password.create("password")
=> "$2a$12$96zNwE5bsABseZbupdpy3OLKrve4dFaDDopXXPPbgllFIp/b6fiO6"

> BCrypt::Password.create("password")
=> "$2a$12$haEjiyYy2.ryk9eh4Bl2MOIOmZ2UfEpsi/LF2qMT3SbnqV3xbQQ3O"
-------------------code----------------------

- we got a different password And this is happening because of "salt" or that piece of text that was added using a random combination
of things When I was creating this and added to the password before it was hashed and Bcrypt has the
mechanism in place to read that piece or that salt piece of text when converting a text that I give
back to the hash.

- now we can see that in action we can take that value using "_"
-------------------code----------------------
> BCrypt::Password.create("password")
=> "$2a$12$OwJ.MX87VGtHgobPk5mFpeGfDiIUOUqGE//C/6gnZ89SeT.4x.0he"

> password = _
=> "$2a$12$OwJ.MX87VGtHgobPk5mFpeGfDiIUOUqGE//C/6gnZ89SeT.4x.0he"
-------------------code----------------------

- now we can see the salt part
-------------------code----------------------
> password.salt
=> "$2a$12$OwJ.MX87VGtHgobPk5mFpe"
-------------------code----------------------

- now let`s test it in our database
-------------------code----------------------
> user = User.first
  User Load (0.3ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT 1 /*application='RailsApp'*/
=>
#<User:0x00000001078a7098
...

> user
=>
#<User:0x00000001078a7098
 id: 1,
 username: "Lili",
 email: "[FILTERED]",
 created_at: "2025-01-02 12:43:15.139987000 +0000",
 updated_at: "2025-01-02 12:43:15.139987000 +0000",
 password_digest: nil>

 > user.password = "password123"
=> "password123"
rails-app(dev)> user.save!
  TRANSACTION (0.3ms)  BEGIN immediate TRANSACTION /*application='RailsApp'*/
  User Exists? (0.2ms)  SELECT 1 AS one FROM "users" WHERE "users"."username" = 'Lili' AND "users"."id" != 1 LIMIT 1 /*application='RailsApp'*/
  User Exists? (0.1ms)  SELECT 1 AS one FROM "users" WHERE "users"."email" = 'lili@bobo.com' AND "users"."id" != 1 LIMIT 1 /*application='RailsApp'*/
  User Update (0.1ms)  UPDATE "users" SET "updated_at" = '2025-01-03 09:58:26.186183', "password_digest" = '$2a$12$6QwdKrZccrPQksVjXdjBSO73ssSn/G8RaQDHsNXIWJx/HnffcSSPi' WHERE "users"."id" = 1 /*application='RailsApp'*/
  TRANSACTION (0.7ms)  COMMIT TRANSACTION /*application='RailsApp'*/
=> true
-------------------code----------------------

- we can see it turned to hashed password in the TRANSACTION
and we can check it and see that it changes
-------------------code----------------------
> user.password_digest
=> "$2a$12$6QwdKrZccrPQksVjXdjBSO73ssSn/G8RaQDHsNXIWJx/HnffcSSPi"
-------------------code----------------------

- now for authenticate we can use the device method which called "authenticate" to check if the password is 
authenticated 
-------------------code----------------------
rails-app(dev)> user.authenticate("password")
=> false
rails-app(dev)> user.authenticate("password123")
=>
#<User:0x00000001078a7098
 id: 1,
 username: "Lili",
 email: "[FILTERED]",
 created_at: "2025-01-02 12:43:15.139987000 +0000",
 updated_at: "2025-01-03 09:58:26.186183000 +0000",
 password_digest: "[FILTERED]">
-------------------code----------------------

- so what we will do when user try to login using either there name or email we will take 
that name and find that user data in the db Then run the authenticate method on that data
Passing in the password that they're entering to see if they are indeed using the right password.


*** 8- New user sign up form ***

we will create sign up form the first 
to access that we don`t want to access 

we want to do is to create sign up route
-------------------code----------------------
http://localhost:3000/user/new
-------------------code----------------------

- instead we want to access it using sginup keyword 
-------------------code----------------------
http://localhost:3000/signup
-------------------code----------------------

- so the first thing to do is to add sigup route and set it to user with the new action 
-------------------code----------------------
get "signup", to: "user#new"
-------------------code----------------------

- now to check if the route is working  we access
-------------------code----------------------
http://localhost:3000/signup
-------------------code----------------------

we got this error so the routing is working fine
-------------------code----------------------
uninitialized constant UserController
-------------------code----------------------

- next we create the controller 
-------------------code----------------------
rails g controller users
-------------------code----------------------

- we add the new action 
-------------------code----------------------
class UsersController < ApplicationController
  def new
    @user = User.new
  end
end
-------------------code----------------------

- next we create the sign up form we do the same approach like the article
we copy form partial and new file  file and change the values
-------------------code----------------------
<h1>Sign up User</h1>

<%= render "form" %>
-------------------code----------------------


and in the form partial we change our labels
-------------------code----------------------
<% if @user.errors.any? %>
  <h2>The following errors prevented the article from being saved</h2>
  <ul>
    <% @user.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
  </ul>
<% end %>

<%= form_with model: @user, local: true do |form| %>
  <div>
    <%= form.label :username %>
    <br/>
    <%= form.text_field :username %>
    
  </div>
  <br/>
  <div>
    <%= form.label :email %>
    <br/>
    <%= form.text_field :email %>
  </div>
  <br/>
  <div>
    <%= form.label :password_digest %>
    <br/>
    <%= form.password_field :password_digest %>
  </div>
  <br/>
  <%= form.submit %>
<% end %>
<p>
  <%= link_to "Cancel and Return to The articles", articles_path %> 
</p>
-------------------code----------------------

- now when we access the sginub route we got error 
-------------------code----------------------
undefined method `users_path' for #<ActionView::Base:0x000000000249f0>
-------------------code----------------------

what happing here is that is looking for the form submission path which we don`t 
have defined in our route 
on our routes we only have the sign up path and since the form deals with the user model, it will look for
a users path defined to submit the post request to once the form is complete and submitted, but right
now it can't find it. on other word we only have get method for the users in our routes and there is no
post route so when the form is submitted rails doesn`t know where tp send the post request
to fix that we add post route and we set it to create 
-------------------code----------------------
post "users", to: "users#create"
-------------------code----------------------

- now the form is working next we must create "create" action 

*** 9-Create new users (back-end) ***

now we want to add the "create" action

- until this point if we clicked on the "Create User" form we got 
-------------------code----------------------
AbstractController::ActionNotFound (The action 'create' could not be found for UsersController):
-------------------code----------------------

- we add "create" action and debug the code
-------------------code----------------------
def create
  debugger
end
-------------------code----------------------

- and we fill the sign up form and click on the "Create User"
and check the params 
-------------------code----------------------
(rdbg) params
#<ActionController::Parameters {"authenticity_token"=>"BaJv8UAzxUz1-HLPKCI-k62tXZ63aNuXq1tGKvbz-s4xgrJAHTSmVPSQmOpr0zul7FMDDvhWdiBEH4Lbl8BY0Q", "user"=>{"username"=>"moody", "email"=>"moody@example.com", "password_digest"=>"test123"}, "commit"=>"Create User",
 "controller"=>"users", "action"=>"create"} permitted: false>
-------------------code----------------------


- we can check what we pass by add params with top key which is user 
-------------------code----------------------
params[:user]
#<ActionController::Parameters {
  "username"=>"moody", "email"=>"moody@example.com", "password_digest"=>"test123"} permitted: false>
-------------------code----------------------

- now we see all the parameters username, email, password_digest
now we need to permit it
-------------------code----------------------  
def create
  @user = User.new(user_params)
  if @user.save
    flash[:notice] = "Welcome, you have successfully signed up"
    redirect_to articles_path
  else
    render :new
  end
end

private

def user_params
  params.require(:user).permit(:username, :email, :password_digest)
end
-------------------code----------------------

- now to show the user name dynamically on the flash message
-------------------code----------------------
flash[:notice] = "Welcome #{@user.username}, you have successfully signed up"
-------------------code----------------------


PS: for shared/_errors.html.erb to show which class name has error 
we use 
-------------------code----------------------
obj.class.name.downcase
-------------------code----------------------


- next we fix the button name of the form 
-------------------code----------------------
<%= form.submit "Sign up" %>
-------------------code----------------------

*** 10-Edit users ***
we will make the user to be able to edit there profile using the browser

- now we add the users resources without new cause we already use it with sign up 
and in resources we already have create so we remove the post 
-------------------code----------------------
post "users", to: "users#create"
-------------------code----------------------

- and add the resource without new action
-------------------code----------------------
resources :users, expect: [:new]
-------------------code----------------------

- now we will check the user edit routes to do that we use pip with routes 
-------------------code----------------------
rails routes --expanded | grep edit
-------------------code----------------------

- we got all the routes with edit 
-------------------code----------------------
$ rails routes --expanded | grep edit
Prefix            | edit_article
URI               | /articles/:id/edit(.:format)
Controller#Action | articles#edit
Prefix            | edit_user
URI               | /users/:id/edit(.:format)
Controller#Action | users#edit {:expect=>[:new]}
-------------------code----------------------

PS: before we created users without passwords 
so we pick a user for test with password  
the empty line is nil
-------------------code----------------------
> User.all.each do |u|
  *   puts u.password_digest
> end
  User Load (0.3ms)  SELECT "users".* FROM "users" /*application='RailsApp'*/
$2a$12$6QwdKrZccrPQksVjXdjBSO73ssSn/G8RaQDHsNXIWJx/HnffcSSPi


test123
test123
test123

[#<User:0x000000010acf93a0
  id: 1,
  username: "Lili",
  email: "[FILTERED]",
  created_at: "2025-01-02 12:43:15.139987000 +0000",
  updated_at: "2025-01-03 09:58:26.186183000 +0000",
  password_digest: "[FILTERED]">,
 #<User:0x000000010acf9260
  id: 2,
  username: "Mike",
  email: "[FILTERED]",
  created_at: "2025-01-02 13:00:06.561071000 +0000",
  updated_at: "2025-01-02 13:00:06.561071000 +0000",
  password_digest: nil>,
 #<User:0x000000010acf9120
  id: 3,
  username: "Mike3",
  email: "[FILTERED]",
  created_at: "2025-01-02 13:04:24.101605000 +0000",
  updated_at: "2025-01-02 13:04:24.101605000 +0000",
  password_digest: nil>,
 #<User:0x000000010acf8fe0
  id: 4,
  username: "moody",
  email: "[FILTERED]",
  created_at: "2025-01-04 07:32:54.412449000 +0000",
  updated_at: "2025-01-04 07:32:54.412449000 +0000",
  password_digest: "[FILTERED]">,
 #<User:0x000000010acf8ea0
  id: 5,
  username: "moody2",
  email: "[FILTERED]",
  created_at: "2025-01-04 07:33:32.684527000 +0000",
  updated_at: "2025-01-04 07:33:32.684527000 +0000",
  password_digest: "[FILTERED]">,
 #<User:0x000000010acf89a0
  id: 6,
  username: "moody3",
  email: "[FILTERED]",
  created_at: "2025-01-04 07:35:11.568630000 +0000",
  updated_at: "2025-01-04 07:35:11.568630000 +0000",
  password_digest: "[FILTERED]">]
-------------------code----------------------

- we will use user without password_digest for example id: 3
-------------------code----------------------
http://localhost:3000/users/3/edit
-------------------code----------------------

- we got error so we build the edit action
-------------------code----------------------
The action 'edit' could not be found for UsersController
-------------------code----------------------

- edit action will be similar to article edit action 
we will find that user based on the id params 
-------------------code----------------------
def edit
  @user = User.find(params[:id])
end
-------------------code----------------------

- we got different error so next we create the edit template 
-------------------code----------------------
UsersController#edit is missing a template for request formats: text/html
-------------------code----------------------

- the edit template will be similar to the user with just change the header name 
-------------------code----------------------
<h1>Edit User</h1>

<%= render "form" %>
-------------------code----------------------


- now we can see the submission button for the form is called "sign up"
so we need to change it to do that we can check if the current user is a new record
using the "new_record?" method
-------------------code----------------------
<%= form.submit(@user.new_record? ? "Sign up" : "Update account")%>
-------------------code----------------------


- now we test if the name of the button is working 


- next we try to change the user name and press update account we got 
-------------------code----------------------
AbstractController::ActionNotFound (The action 'update' could not be found for UsersController):
-------------------code----------------------

- so we define the update action 
-------------------code----------------------
def update 
  @user = User.find(params[:id])
  if @user.update(user_params)
    flash[:notice] = "User was updated successfully"
    redirect_to articles_path
  else 
    render :edit
  end
end
-------------------code----------------------

- we couldn`t update we use debugger to see the problem 
-------------------code----------------------
def update 
  @user = User.find(params[:id])
  debugger
  if @user.update(user_params)
    flash[:notice] = "User was updated successfully"
    redirect_to articles_path
  else 
    render :edit
  end
end
-------------------code----------------------

- we try to update then we check the error 
-------------------code----------------------
  User Load (0.1ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 3 LIMIT 1 /*action='update',application='RailsApp',controller='users'*/
  ↳ app/controllers/users_controller.rb:11:in `update'
[7, 16] in ~/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/users_controller.rb
     7|     @user = User.find(params[:id])
     8|   end
     9|
    10|   def update
    11|     @user = User.find(params[:id])
=>  12|     debugger
    13|     if @user.update(user_params)
    14|       flash[:notice] = "User was updated successfully"
    15|       redirect_to articles_path
    16|     else
=>#0	UsersController#update at ~/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/users_controller.rb:12
  #1	ActionController::BasicImplicitRender#send_action(method="update", args=[]) at ~/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/actionpack-8.0.1/lib/action_controller/metal/basic_implicit_render.rb:8
  # and 79 frames (use `bt' command for all frames)
(ruby) @user.update(user_params)
  TRANSACTION (0.1ms)  BEGIN immediate TRANSACTION /*action='update',application='RailsApp',controller='users'*/
  ↳ (rdbg)//Users/mahmouddabbbagh/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/users_controller.rb:1:in `update'
  User Exists? (5.6ms)  SELECT 1 AS one FROM "users" WHERE "users"."username" = 'Mike23' AND "users"."id" != 3 LIMIT 1 /*action='update',application='RailsApp',controller='users'*/
  ↳ (rdbg)//Users/mahmouddabbbagh/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/users_controller.rb:1:in `update'
  User Exists? (0.1ms)  SELECT 1 AS one FROM "users" WHERE "users"."email" = 'mikessp@example.com' AND "users"."id" != 3 LIMIT 1 /*action='update',application='RailsApp',controller='users'*/
  ↳ (rdbg)//Users/mahmouddabbbagh/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/users_controller.rb:1:in `update'
  TRANSACTION (0.1ms)  ROLLBACK TRANSACTION /*action='update',application='RailsApp',controller='users'*/
  ↳ (rdbg)//Users/mahmouddabbbagh/moody/Rails/The-Complete-Ruby-on-Rails-Developer-Course/Section-4:-Associations-and-Authentication-Systems/rails-app/app/controllers/users_controller.rb:1:in `update'
false
(ruby) @user.errors.full_messages
["Password can't be blank"]
-------------------code----------------------

- the error says "Password can't be blank" cause we created this user before add the password_digest
column 

- to solve that we add password and try to change the name

- and it worked successfully

- next we will try to update user with password for example 1
-------------------code----------------------
http://localhost:3000/users/1/edit
-------------------code----------------------

- we got error cause we pass nil password 
to fix that we need to avoid permitting the "password_digest" if it empty
so we fix the user params 
-------------------code----------------------
def user_params
  permitted = [:username, :email]
  permitted << :password_digest if params[:user][:password_digest].present?
  params.require(:user).permit(permitted)
end
-------------------code----------------------

*** 11-Show user and profile image ***
we will show the user profile and add profile image 

- we create show action
-------------------code----------------------
def show 
  @user = User.find(params[:id])
end
-------------------code----------------------

- and same as the article cause we used the User.find in multi places 
we save it different method and called with before action
-------------------code----------------------
def set_user
  @user = User.find(params[:id])
end
-------------------code----------------------

and we set the before action 
-------------------code----------------------
before_action :set_user, only: [:show, :edit, :update]
-------------------code----------------------

- now our controller look like this 
-------------------code----------------------
class UsersController < ApplicationController
  before_action :set_user, only: [:show, :edit, :update]

  def new
    @user = User.new
  end

  def show 
  end

  def edit
  end

  def update 
    if @user.update(user_params)
      flash[:notice] = "User was updated successfully"
      redirect_to articles_path
    else 
      render :edit
    end
  end

  def create
    @user = User.new(user_params)
    if @user.save
      flash[:notice] = "Welcome #{@user.username}, you have successfully signed up"
      redirect_to articles_path
    else
      render :new
    end
  end

  private
  def set_user
    @user = User.find(params[:id])
  end

  def user_params
    permitted = [:username, :email]
    permitted << :password_digest if params[:password_digest].present?
    params.require(:user).permit(permitted)
  end
end
-------------------code----------------------

- next we will create the show template similar to article but we will change the columns name
-------------------code----------------------
<h1>Profile Details</h1>
<p><strong>Username: </strong><%= @user.username %></p>
<p><strong>Email: </strong><%= @user.email %></p>
-------------------code----------------------

- next if we want to show the articles of that user on there profile Detail
- in controller we grab all the articles 
-------------------code----------------------
def show 
  @articles = @user.articles
end
-------------------code----------------------

- next we can show the article titles of that user 
-------------------code----------------------
<% @articles.each do |article| %>
  <p><%= article.title %></p>
<% end %>
-------------------code----------------------

- now to refactor our code we add @articles to partial and called in articles/index.html.erb
and users/show.html.erb

we create articles/_articles.html.erb
-------------------code----------------------
<% @articles.each do |article| %>
  <tr>
    <td><%= article.title %></td>
    <td><%= article.description %></td>
    <td><%= article.user.username %></td>
    <td><%= link_to "Show", article_path(article) %></td>
    <td><%= link_to "Edit", edit_article_path(article) %></td>
    <td><%= button_to "Delete", article_path(article), method: :delete, data: { turbo_confirm: "Are you sure you want to delete this article?" } %></td>
  </tr>
<% end %>
-------------------code----------------------

- now we render it in the index.html.erb
-------------------code----------------------
<tbody>
  <%= render "articles" %>
</tbody>
-------------------code----------------------

- and we add it to the users/show.html.erb
Ps: when we use the partial of other file we set the full path
-------------------code----------------------
<h1>Profile Details</h1>
<p><strong>Username: </strong><%= @user.username %></p>
<p><strong>Email: </strong><%= @user.email %></p>
<%= render "articles/articles" %>
-------------------code----------------------

- for the profile image i will not use Gravatar program so i will not add it 

- PS: if we want to create method and called it in the view file 
we use the helper/application_helper.rb file 

*** 12-Add users index ***
we will create the users index page 


- we already have the routes so we start by create the index action
-------------------code----------------------
def index
  @users = User.all
end
-------------------code----------------------

- next we create the index.html.erb
-------------------code----------------------
<h1>Users list pages</h1>
<table>
  <thead>
    <tr>
      <th>Username</th>
      <th>Email</th>
      <th>Articles Number</th>
      <th colspan="2" >Details</th>
      <th>Joins</th>
    </tr>
  </thead>
  <tbody>
    <% @users.each do |user| %>
      <tr>
        <td><%= user.username %></td>
        <td><%= user.email %></td>
        <td><%= pluralize(user.articles.count, "article") %></td>
        <td><%= link_to "Show Profile", user_path(user) %></td>
        <td><%= link_to "Edit Profile", edit_user_path(user) %></td>
        <td><%= "#{time_ago_in_words(user.created_at)} ago" %></td>
      </tr>
    <% end %>
  </tbody>
</table>
-------------------code----------------------

- PS: 
1- for counting the article we use pluralize method 
The pluralize method in Ruby on Rails is a helper method used to display a word in its plural form based on a given count. 
It takes two arguments: the count and the singular form of the word. If the count is greater than one,
 it returns the pluralized version of the word; otherwise, it returns the singular form.
-------------------code----------------------
> pluralize(1, "article")
=> 1 article

> pluralize(3, "article")
=> 3 articles
-------------------code----------------------

2- time_ago_in_words 
The time_ago_in_words method in Rails is used to display a human-readable string that represents the time elapsed since a given time. It is often used in views to show how long ago an event occurred, such as when a user joined or when an article was created.
ex:
-------------------code----------------------
> "#{time_ago_in_words(user.created_at)} ago"
=> 3 days ago
-------------------code----------------------

*** 13-Cleanup layout ***
- first we will fix the redirection in the users controller
before we didn`t have a show template for the users so after update
we redirect_to the articles now we redirect_to user_path 
-------------------code----------------------
def update 
    if @user.update(user_params)
      flash[:notice] = "User was updated successfully"
      redirect_to @user
    else 
      render :edit
    end
  end
-------------------code----------------------

- now we test our code 

-then we do the same thing to our create action
we check the index action Prefix
-------------------code----------------------
$ rails routes --expanded | grep user
Controller#Action | users#new
Prefix            | users
URI               | /users(.:format)
Controller#Action | users#index
URI               | /users(.:format)
Controller#Action | users#create
Prefix            | edit_user
URI               | /users/:id/edit(.:format)
Controller#Action | users#edit
Prefix            | user
URI               | /users/:id(.:format)
Controller#Action | users#show
URI               | /users/:id(.:format)
Controller#Action | users#update
URI               | /users/:id(.:format)
Controller#Action | users#update
URI               | /users/:id(.:format)
Controller#Action | users#destroy
-------------------code----------------------

- then we change the create action
-------------------code----------------------
def create
  @user = User.new(user_params)
  if @user.save
    flash[:notice] = "Welcome #{@user.username}, you have successfully signed up"
    redirect_to users_path
  else
    render :new
  end
end
-------------------code----------------------

- next we change the Users in article show template to go to that users 
-------------------code----------------------
<h1>Showing article details</h1>
<p><strong>Title: </strong><%= @article.title %></p>
<p><strong>Description: </strong><%= @article.description %></p>
<p><strong>User: </strong><%= @article.user.username %></p>
-------------------code----------------------

- and user the link_to 
-------------------code----------------------
<p><strong>User: </strong><%= link_to @article.user.username, user_path(@article.user) %></p>
-------------------code----------------------

- and we do the same for the _articles partial
-------------------code----------------------
<% @articles.each do |article| %>
  <tr>
    <td><%= article.title %></td>
    <td><%= article.description %></td>
    <td><%= article.user.username %></td>
    <td><%= link_to "Show", article_path(article) %></td>
    <td><%= link_to "Edit", edit_article_path(article) %></td>
    <td><%= button_to "Delete", article_path(article), method: :delete, data: { turbo_confirm: "Are you sure you want to delete this article?" } %></td>
  </tr>
<% end %>
-------------------code----------------------


- and we add link_to
-------------------code----------------------
<% @articles.each do |article| %>
  <tr>
    <td><%= article.title %></td>
    <td><%= article.description %></td>
    <td><%= link_to article.user.username, user_path(article.user) %></td>
    <td><%= link_to "Show", article_path(article) %></td>
    <td><%= link_to "Edit", edit_article_path(article) %></td>
    <td><%= button_to "Delete", article_path(article), method: :delete, data: { turbo_confirm: "Are you sure you want to delete this article?" } %></td>
  </tr>
<% end %>
-------------------code----------------------

*** 14- Add pagination to views ***
we will add pagination to our articles 

- in our controllers when we show all users or articles we 
use Article.all or Article.order for Example: 
-------------------code----------------------
def index
  @articles = Article.order(created_at: :desc)
end
-------------------code----------------------

- so the idea is that in the index we want to add the limit for each page 

- to add pagination first we are going to add a gem called 
https://rubygems.org/gems/will_paginate
-------------------code----------------------
will_paginate
-------------------code----------------------

- according to the document we will add the version in the gem file
-------------------code----------------------
# Pagination
gem 'will_paginate', '~> 4.0', '>= 4.0.1'
-------------------code----------------------

******************************************************************************************************
- Specifying the version of a gem in your Gemfile is important for several reasons:
1.Stability: By locking a gem to a specific version, you ensure that your application will behave
consistently across different environments (development, testing, production).
This prevents unexpected changes in behavior that could occur if a newer version of the gem introduces breaking changes or bugs.

2.Compatibility: Different versions of a gem may have different APIs or dependencies. 
Specifying a version helps ensure that your application remains compatible with the versions of other gems
and libraries it depends on.

3. Security: Sometimes, newer versions of gems include important security patches. 
By specifying a version, you can control when to upgrade to a version that includes these patches,
ensuring that your application is secure.

4.Dependency Management: Some gems depend on specific versions of other gems.
By specifying versions, you can avoid conflicts that may arise from incompatible versions of dependencies.

5.6msPredictability: When you specify a version, you can predict how your application will behave when you deploy it or when other developers work on it.
This predictability is crucial for team collaboration and continuous integration/continuous deployment (CI/CD) processes.

6. Documentation and Support: When you specify a version, it becomes easier to refer to documentation or seek support for that specific version.
This can be helpful when troubleshooting issues or when looking for community help.

In summary, specifying the version of a gem helps maintain the integrity, security, and reliability of your application.

if we add gem 'will_paginate' to your Gemfile without specifying a version, Rails (or more accurately, Bundler) will install the latest version of that gem available at the time you run bundle install. This means that if a new version of the gem is released after you initially installed it, your application could potentially use that new version the next time you run bundle install, which might introduce breaking changes or unexpected behavior.

- he behavior of bundle install depends on how you specify the gem versions in your Gemfile:
1. Without Version Specification: If you add a gem without specifying a version (e.g., gem 'will_paginate'), bundle install will install the latest version available at that time. 
If a new version is released later, running bundle install again will update to that new version.

1. Without Version Specification: If you add a gem without specifying a version (e.g., gem 'will_paginate'),
bundle install will install the latest version available at that time. 
If a new version is released later, running bundle install again will update to that new version.

2. With Version Specification: If you specify a version or a version range (e.g., gem 'will_paginate', '~> 4.0'),
Bundler will install the latest version that matches the specified criteria. For example:
- gem 'will_paginate', '~> 4.0' will allow any version from 4.0.0 up to (but not including) 5.0.0.
- If a new version (e.g., 4.1.0) is released, running bundle install will update to that version, but it will not update to 5.0.0 or higher.

3.Exact Version: If you specify an exact version (e.g., gem 'will_paginate', '4.0.1'), 
Bundler will always install that specific version, and it will not update to any newer versions unless you change the version in your Gemfile.

4.Using bundle update: If you want to update your gems to the latest versions that match the specified criteria in your Gemfile, you can run bundle update. 
This command will update all gems to the latest versions allowed by your Gemfile.

In summary, bundle install will not automatically download the latest version of a gem if you have specified a version or version range in your Gemfile. 
It will only install the latest version that fits within the constraints you've set.

******************************************************************************************************


- now according to the basic of how it use 
https://www.rubydoc.info/gems/will_paginate/4.0.1
-------------------code----------------------
## perform a paginated query:
@posts = Post.paginate(page: params[:page])

# or, use an explicit "per page" limit:
Post.paginate(page: params[:page], per_page: 30)

## render page links in the view:
<%= will_paginate @posts %>
-------------------code----------------------


- so in the articles controller we add the paginate code
and we adjust the page to 5
-------------------code----------------------
def index
  # @articles = Article.order(created_at: :desc)
  @articles = Article.paginate(page: params[:page], per_page: 5)
end
-------------------code----------------------


- next we add the render to index template
-------------------code----------------------
<tbody>
  <%= will_paginate @articles %>
  <%= render "articles" %>
</tbody>
-------------------code----------------------


- and we test it 

- finally we add the ordering 
Ps: we change the order to update_all to show the newest and the updated articles first
-------------------code----------------------
def index
  @articles = Article.order(updated_at: :desc).paginate(page: params[:page], per_page: 5)
end
-------------------code----------------------

- to add styles we press inside the will_paginate gem 
we add we go to 
-------------------code----------------------
You just need to add some CSS styles to make those pagination links prettier.
-------------------code----------------------

- and inside the CSS style page we want to apply the "Flickr.com"
so we go to the Css in the top on the page and copy the the styles that related to Flickr
and add in assets/application.css
-------------------code----------------------
/* Pagination */
.flickr_pagination {
  text-align: center;
  padding: 0.3em;
  cursor: default;
}
.flickr_pagination a,
.flickr_pagination span,
.flickr_pagination em {
  padding: 0.2em 0.5em;
}
.flickr_pagination .disabled {
  color: #aaaaaa;
}
.flickr_pagination .current {
  font-style: normal;
  font-weight: bold;
  color: #ff0084;
}
.flickr_pagination a {
  border: 1px solid #dddddd;
  color: #0063dc;
  text-decoration: none;
}
.flickr_pagination a:hover,
.flickr_pagination a:focus {
  border-color: #003366;
  background: #0063dc;
  color: white;
}
.flickr_pagination .page_info {
  color: #aaaaaa;
  padding-top: 0.8em;
}
.flickr_pagination .previous_page,
.flickr_pagination .next_page {
  border-width: 2px;
}
.flickr_pagination .previous_page {
  margin-right: 1em;
}
.flickr_pagination .next_page {
  margin-left: 1em;
}
-------------------code----------------------

- now in the document it says 
Code that renders this:
-------------------code----------------------
<div class="digg_pagination">
  <div class="page_info">
    <%= page_entries_info @posts %>
  </div>
  <%= will_paginate @posts, :container => false %>
</div>
-------------------code----------------------

- so we apply the same thing and we want to add the pagination in top and down of articles
-------------------code----------------------
<tbody>
  <div class="flickr_pagination">
    <%= will_paginate @articles, :container => false %>
  </div>
  <%= render "articles" %>
</tbody>
</table>
<p>
  <%= link_to "Create New Article", new_article_path %> 
</p>
<div class="flickr_pagination">
  <%= will_paginate @articles, :container => false %>
</div>
-------------------code----------------------

- next we do the same thing to the Users 
-------------------code----------------------
def index
  @users = User.order(updated_at: :desc).paginate(page: params[:page], per_page: 5)
end
-------------------code----------------------


then we render it in index template
-------------------code----------------------
<tbody>
  <div class="flickr_pagination">
    <%= will_paginate @users, :container => false %>
  </div>
  <%= render "users" %>
</tbody>
</table>
<div class="flickr_pagination">
  <%= will_paginate @users, :container => false %>
</div>
-------------------code----------------------

- and we want to the same thing to the articles in the users show action 
-------------------code----------------------
def show 
  @articles = @user.articles.paginate(page: params[:page], per_page: 5)
end
-------------------code----------------------

- then for the show template
-------------------code----------------------
<div class="flickr_pagination">
  <%= will_paginate @articles, :container => false %>
</div>
<%= render "articles/articles" %>
<div class="flickr_pagination">
  <%= will_paginate @articles, :container => false %>
</div>
-------------------code----------------------
